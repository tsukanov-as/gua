// MIT License

// Copyright (c) 2021 tsukanov-as

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

string_byte := _G.string.byte
string_sub := _G.string.sub
string_rep := _G.string.rep
string_format := _G.string.format
string_find := _G.string.find
table_concat := _G.table.concat
table_sort := _G.table.sort
tonumber := _G.tonumber
assert := _G.assert
setmetatable := _G.setmetatable
pairs := _G.pairs
ipairs := _G.ipairs
tostring := _G.tostring
error := _G.error
type := _G.type

Type := {
    __call: func(self, t) {
        if self.init {
            t = self.init(t)
        }
        return setmetatable(t, self)
    },
}
setmetatable(Type, Type)

Hex := Type({
    __tostring: func(t) {
        return string_format("0x%02X", t[1])
    },
})

Raw := Type({
    __tostring: func(t) {
        s := t[1]
        i := 0
        x := nil
        for {
            x = string_rep("=", i)
            if !string_find(s, "[" .. x .. "[", 1, true)
                && !string_find(s, "]" .. x .. "]", 1, true) {
                break
            }
            i += 1
        }
        return string_format(" [%s[%s]%s]", x, s, x)
    },
})

List := Type({
    __tostring: func(t) {
        res := {}
        for i, v in ipairs(t) {
            if type(v) == "string" {
                res[i] = string_format("%q", v)
            } else {
                res[i] = tostring(v)
            }
        }
        return "{" .. table_concat(res, ", ") .. "}"
    },
})

Set := Type({
    __tostring: func(t) {
        res := {}
        for k in pairs(t) {
            if type(k) == "string" {
                res[#res+1] = string_format("%q", k)
            } else {
                res[#res+1] = tostring(k)
            }
        }
        table_sort(res)
        return "{" .. table_concat(res, ", ") .. "}"
    },
    init: func(self, t) {
        set := {}
        for _, v in ipairs(t) {
            set[v] = v
        }
        return set
    },
})

Fields := Type({
    __tostring: func(t) {
        res := {}
        for i, v in ipairs(t) {
            res[#res+1] = string_format("%d:%q", i, v)
        }
        table_sort(res)
        return "{" .. table_concat(res, ", ") .. "}"
    },
    init: func(self, t) {
        fields := {}
        for i, v in ipairs(t) {
            fields[i] = v
            fields[v] = i
        }
        return fields
    },
})

nodes := {
    "module"   : Fields(["Type", "Pos", "Len", "Body", "Comments"]),
    "value"    : Fields(["Type", "Pos", "Len", "Value"]),
    "field"    : Fields(["Type", "Pos", "Len", "Args", "Name", "Dot"]),
    "index"    : Fields(["Type", "Pos", "Len", "Expr"]),
    "id"       : Fields(["Type", "Pos", "Len", "Name", "Tail", "Args", "Const"]),
    "table"    : Fields(["Type", "Pos", "Len", "List"]),
    "pair"     : Fields(["Type", "Pos", "Len", "Left", "Right"]),
    "list"     : Fields(["Type", "Pos", "Len", "List"]),
    "paren"    : Fields(["Type", "Pos", "Len", "Expr"]),
    "unop"     : Fields(["Type", "Pos", "Len", "Op", "Expr"]),
    "binop"    : Fields(["Type", "Pos", "Len", "Left", "Op", "Right"]),
    "call"     : Fields(["Type", "Pos", "Len", "ID"]),
    "set"      : Fields(["Type", "Pos", "Len", "Left", "Right"]),
    "let"      : Fields(["Type", "Pos", "Len", "Left", "Right"]),
    "inc"      : Fields(["Type", "Pos", "Len", "ID", "Expr"]),
    "dec"      : Fields(["Type", "Pos", "Len", "ID", "Expr"]),
    "if"       : Fields(["Type", "Pos", "Len", "Expr", "Then", "Else", "Left", "Right"]),
    "block"    : Fields(["Type", "Pos", "Len", "Body"]),
    "for"      : Fields(["Type", "Pos", "Len", "Expr", "Body"]),
    "for_to"   : Fields(["Type", "Pos", "Len", "ID", "From", "Limit", "Step", "Body"]),
    "for_in"   : Fields(["Type", "Pos", "Len", "IDs", "INs", "Body"]),
    "return"   : Fields(["Type", "Pos", "Len", "List"]),
    "break"    : Fields(["Type", "Pos", "Len", "Expr"]),
    "continue" : Fields(["Type", "Pos", "Len"]),
    "label"    : Fields(["Type", "Pos", "Len", "Name"]),
    "func"     : Fields(["Type", "Pos", "Len", "Name", "Params", "Body", "Receiver"]),
    "receiver" : Fields(["Type", "Pos", "Len", "Name", "ID"]),
    "nop"      : Fields(["Type", "Pos", "Len"]),
    "vararg"   : Fields(["Type", "Pos", "Len"]),
    "param"    : Fields(["Type", "Pos", "Len", "Name"]),
    "params"   : Fields(["Type", "Pos", "Len", "List"]),
    "switch"   : Fields(["Type", "Pos", "Len", "Expr", "Cases", "Default"]),
    "case"     : Fields(["Type", "Pos", "Len", "List", "Expr", "Body"]),
    "const"    : Fields(["Type", "Pos", "Len", "List"]),
}

Node := Type({
    __tostring: List.__tostring,
    __index: func(t, k) {
        if type(k) == "string" {
            _type := t[1]
            if k == "Type" {
                return _type
            }
            return t[nodes[_type][k]]
        }
        return nil
    },
})

KEYWORDS := Set(["break", "continue", "else", "false", "for", "func", "if", "in", "nil", "return", "true", "switch", "case", "default", "const"])
RESERVED := Set(["local", "function", "while", "do", "end", "repeat", "until", "and", "or", "not", "then", "elseif"])
LITERALS := Set(["str", "chr", "raw", "num", "true", "false", "nil"])
REL_OPS := Set(["==", "!=", "<", ">", "<=", ">="])
MUL_OPS := Set(["*", "/", "%"])
ADD_OPS := Set(["+", "-"])
UNR_OPS := Set(["+", "-", "!", "#"])

const (
    LF = 0x0A
    ALPHA = 1
    DIGIT = 2
    SPACE = 3
)

MAP := {
    '"': "str",
    '\'': "chr",
    '`': "raw",
}
HEX := {}
ALPHA_OR_DIGIT := {}
{
    byte, sub := string_byte, string_sub

    sym := "()[]{}*:;.,/+-=<>#%|&!^"
    for i := 1, #sym {
        MAP[byte(sym, i)] = sub(sym, i, i)
    }
    for i := 0x1, ' ' {
        MAP[i] = SPACE
    }
    for i := '0', '9' {
        MAP[i] = DIGIT; ALPHA_OR_DIGIT[i] = true
    }

    abc := "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    for i := 1, #abc {
        MAP[byte(abc, i)] = ALPHA; ALPHA_OR_DIGIT[byte(abc, i)] = true
    }

    hex := "ABCDEFabcdef0123456789"
    for i := 1, #hex {
        HEX[byte(hex, i)] = true
    }
}

// parser state
p_path := nil
p_src := nil
p_line := 1
p_curpos := 0
p_tokpos := 0 // current token pos
p_endpos := 0 // previous token end pos
p_chr := nil
p_tok := nil
p_lit := ""
p_val := nil
p_comments := List([])
p_vars := {}
p_scope := {}
p_level := 0
p_left := false
p_continue := List([])
p_looplevel := 0

func errorf(notef, ...) {
    if p_path {
        error(p_path .. ":" .. p_line .. ": " .. string_format(notef, ...), 2)
    } else {
        error(string_format(notef, ...) .. " in line " .. p_line, 2)
    }
}

func scan() {
    byte := string_byte
    src := p_src
    pos := p_curpos
    chr := p_chr
    tok := nil
    for {
        tok = MAP[chr]
        p_lit = ""
        p_val = nil
        p_endpos = pos
        for tok == SPACE {
            if chr == LF {
                p_line = p_line + 1
            }
            pos += 1; chr = byte(src, pos)
            tok = MAP[chr]
        }
        p_tokpos = pos
        switch tok {
        case ALPHA:
            AD := ALPHA_OR_DIGIT
            beg := pos
            for {
                pos += 1; chr = byte(src, pos);
                break if !AD[chr]
            }
            p_lit = string_sub(src, beg, pos-1)
            tok = KEYWORDS[p_lit] || "id"
            if tok == "true" {
                p_val = true
            } else if tok == "false" {
                p_val = false
            }
        case DIGIT:
            beg := pos
            base := 10
            if chr == '0' {
                pos += 1; chr = byte(src, pos)
                switch chr {
                case 'X', 'x':
                    pos += 1; chr = byte(src, pos)
                    beg = pos
                    if !HEX[chr] {
                        errorf("expected hex digit, found '%c'", chr)
                    }
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if !HEX[chr]
                    }
                    base = 16
                    if pos-beg > 8 {
                        errorf("integer greater than 32 bits", tok)
                    }
                case 'B', 'b':
                    pos += 1; chr = byte(src, pos)
                    beg = pos
                    if chr != '0' && chr != '1' {
                        errorf("expected bin digit, found '%c'", chr)
                    }
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if chr != '0' && chr != '1'
                    }
                    base = 2
                    if pos-beg > 32 {
                        errorf("integer greater than 32 bits", tok)
                    }
                }
            }
            if base == 10 {
                for MAP[chr] == DIGIT {
                    pos += 1; chr = byte(src, pos)
                }
                if chr == '.' {
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if MAP[chr] != DIGIT
                    }
                }
                if chr == 'E' || chr == 'e' {
                    pos += 1; chr = byte(src, pos)
                    if chr == '+' || chr == '-' {
                        pos += 1; chr = byte(src, pos)
                    }
                    if MAP[chr] != DIGIT {
                        errorf("expected digit, found '%s'", tok)
                    }
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if MAP[chr] != DIGIT
                    }
                }
            }
            tok = "num"
            p_lit = string_sub(src, beg, pos-1)
            if base == 10 {
                p_val = tonumber(p_lit)
            } else {
                p_val = Hex([tonumber(p_lit, base)])
            }
            if p_val == nil {
                errorf("malformed number '%s'", p_lit)
            }
        case "str":
            beg := pos
            for {
                pos += 1; chr = byte(src, pos)
                if chr == '\\' {
                    pos += 2; chr = byte(src, pos)
                }
                break if chr == '"' || chr == LF || chr == nil
            }
            if chr != '"' {
                errorf("expected \", found EOL")
            }
            p_lit = string_sub(src, beg+1, pos-1)
            p_val = p_lit
            pos += 1; chr = byte(src, pos)
        case "raw":
            beg := pos
            for {
                pos += 1; chr = byte(src, pos)
                if chr == LF {
                    p_line = p_line + 1
                }
                break if chr == '`' || chr == nil
            }
            if chr != '`' { errorf("expected `, found '%c'", chr) }
            p_lit = string_sub(src, beg+1, pos-1)
            p_val = Raw([p_lit])
            pos += 1; chr = byte(src, pos)
        case "chr":
            beg := pos
            pos += 1; chr = byte(src, pos)
            if chr == '\\' {
                beg = pos
                pos += 1; chr = byte(src, pos)
            }
            pos += 1; chr = byte(src, pos)
            if chr != '\'' {
                errorf("expected ', found '%c'", chr)
            }
            p_lit = string_sub(src, beg+1, pos-1)
            p_val = Hex([string_byte(p_lit)])
            pos += 1; chr = byte(src, pos)
        case nil; chr != nil:
            errorf("unknown symbol '%c'", chr)
        default:
            old := chr
            pos += 1; chr = byte(src, pos)
            switch chr {
            case '=':
                switch old {
                case ':': tok = ":="; pos += 1; chr = byte(src, pos)
                case '=': tok = "=="; pos += 1; chr = byte(src, pos)
                case '+': tok = "+="; pos += 1; chr = byte(src, pos)
                case '-': tok = "-="; pos += 1; chr = byte(src, pos)
                case '<': tok = "<="; pos += 1; chr = byte(src, pos)
                case '>': tok = ">="; pos += 1; chr = byte(src, pos)
                case '!': tok = "!="; pos += 1; chr = byte(src, pos)
                }
            case ':':
                if old == ':' {
                    tok = "::"
                    pos += 1; chr = byte(src, pos)
                }
            case '/':
                if old == '/' {
                    beg := pos
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if chr == LF || chr == nil
                    }
                    p_lit = string_sub(src, beg+1, pos-1)
                    p_comments[p_line] = p_lit
                    tok = "//"
                }
            case '&':
                if old == '&' {
                    tok = "&&"
                    pos += 1; chr = byte(src, pos)
                }
            case '|':
                if old == '|' {
                    tok = "||"
                    pos += 1; chr = byte(src, pos)
                }
            case '.':
                if old == '.' {
                    tok = ".."
                    pos += 1; chr = byte(src, pos)
                    if chr == '.' {
                        tok = "..."
                        pos += 1; chr = byte(src, pos)
                    }
                }
            }
        }
        break if tok != "//"
    }
    p_curpos, p_chr, p_tok = pos, chr, tok
    return p_tok
}

func expect(t, l) {
    if p_tok != t {
        str := nil
        if p_tok == "num" || p_tok == "str" || p_tok == "chr" || p_tok == "id" {
            str = p_lit
        } else {
            str = tostring(p_tok)
        }
        if p_path {
            error(string_format("%s:%d: expected '%s', found '%s'", p_path, p_line, tostring(t), str), l || 2)
        } else {
            error(string_format("expected '%s', found '%s' in line %d", tostring(t), str, p_line), l || 2)
        }
    }
}

func skip(t) {
    expect(t, 3)
    return scan()
}

func open_scope(vars) {
    p_vars = vars || {}
    p_level += 1
    p_scope[p_level] = p_vars
}

func close_scope() {
    p_level -= 1
    p_vars = p_scope[p_level]
}

func find_var(name) {
    if name == "_" {
        return nil
    }
    v := p_vars[name]
    i := p_level
    for v == nil && i > 1 {
        i -= 1
        v = p_scope[i][name]
    }
    return v, i
}

parse_expr := nil
parse_table, parse_list := nil, nil

func parse_tail(call) {
    tail, i := List([]), 0
    for {
        pos := p_tokpos
        dot := (p_tok == ".")
        switch p_tok {
        case ".", "::":
            scan()
            if KEYWORDS[p_lit] == nil {
                expect("id")
            }
            name := p_lit
            args := false
            last := p_tokpos
            scan()
            if p_tok == "(" {
                scan()
                args = List([])
                for p_tok != ")" {
                    args[#args+1] = parse_expr()
                    if p_tok != "," {
                        break
                    }
                    scan()
                }
                last = p_tokpos
                skip(")")
                call = true
            } else {
                call = false
            }
            if args && dot && (KEYWORDS[name] || RESERVED[name]) {
                errorf("name '%s' cannot be used in a method call", name)
            }
            item := Node(["field", pos, last - pos, args || false, name, dot])
            i += 1
            tail[i] = item
        case "[":
            scan()
            if p_tok == "]" {
                errorf("expected expression, found ']'")
            }
            expr := parse_expr()
            skip("]")
            i += 1
            tail[i] = Node(["index", pos, p_endpos-pos, expr])
        default:
            break
        }
    }
    return i > 0 && tail, call
}

func parse_id(must_exist) {
    pos := p_tokpos
    name := p_lit
    if RESERVED[name] {
        errorf("name '%s' is reserved", name)
    }
    id := find_var(name)
    if must_exist && !id {
        errorf("undeclared variable '%s'", name)
    }
    _const := id && id[7] || false
    call := false
    args, tail := false, false
    scan()
    if !_const {
        if p_tok == "(" {
            scan()
            args = List([])
            for p_tok != ")" {
                args[#args+1] = parse_expr()
                if p_tok != "," {
                    break
                }
                scan()
            }
            skip(")")
            call = true
        }
        tail, call = parse_tail(call)
    }
    node := Node(["id", pos, p_endpos-pos, name, tail, args, _const])
    return node, call
}

func parse_paren() {
    pos := p_tokpos
    skip("(")
    expr := parse_expr()
    skip(")")
    return Node(["paren", pos, p_endpos-pos, expr])
}

parse_table = func() {
    pos := p_tokpos
    list := List([])
    skip("{")
    for p_tok != "}" {
        key_pos := p_tokpos
        left := nil
        if p_tok == "id" || KEYWORDS[p_lit] {
            left = Node(["id", key_pos, #p_lit, p_lit, false, false])
            scan()
        } else if p_tok == "[" {
            scan()
            expr := parse_expr()
            skip("]")
            left = Node(["index", key_pos, p_endpos-key_pos, expr])
        } else {
            left = parse_expr()
        }
        expect(":")
        scan()
        right := parse_expr()
        list[#list+1] = Node(["pair", pos, p_endpos-pos, left, right])
        if p_tok != "," {
            break
        }
        scan()
    }
    skip("}")
    return Node(["table", pos, p_endpos-pos, list])
}

parse_list = func() {
    pos := p_tokpos
    list := List([])
    skip("[")
    for p_tok != "]" {
        list[#list+1] = parse_expr()
        if p_tok != "," {
            break
        }
        scan()
    }
    skip("]")
    return Node(["list", pos, p_endpos-pos, list])
}

parse_func := nil

func parse_operand() {
    if node := p_left; node {
        p_left = false
        return node
    }
    switch p_tok {
    case "str":
        pos, len, val := p_tokpos, #p_lit, p_val
        scan()
        tail := parse_tail()
        return Node(["value", pos, len, val, tail])
    case "id":
        return parse_id(true)
    case "(":
        return parse_paren()
    case "{":
        return parse_table()
    case "[":
        return parse_list()
    case "func":
        return parse_func(true)
    case "...":
        node := Node(["vararg", p_tokpos, 3])
        scan()
        return node
    default:
        if LITERALS[p_tok] {
            node := Node(["value", p_tokpos, #p_lit, p_val])
            scan()
            return node
        }
        errorf("expected operand, found '%s'", p_tok)
    }
}

func parse_pow() {
    pos := p_tokpos
    left := parse_operand()
    for p_tok == "^" {
        scan()
        right := parse_operand()
        left = Node(["binop", pos, p_endpos-pos, left, "^", right])
    }
    return left
}

func parse_unary() {
    pos := p_tokpos
    expr := nil
    if !p_left && UNR_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_pow()
        expr = Node(["unop", pos, p_endpos-pos, op, right])
    } else {
        expr = parse_pow()
    }
    return expr
}

func parse_mul() {
    pos := p_tokpos
    left := parse_unary()
    for MUL_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_unary()
        left = Node(["binop", pos, p_endpos-pos, left, op, right])
    }
    return left
}

func parse_add() {
    pos := p_tokpos
    left := parse_mul()
    for ADD_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_mul()
        left = Node(["binop", pos, p_endpos-pos, left, op, right])
    }
    return left
}

func parse_cat() {
    pos := p_tokpos
    left := parse_add()
    for p_tok == ".." {
        scan()
        right := parse_add()
        left = Node(["binop", pos, p_endpos-pos, left, "..", right])
    }
    return left
}

func parse_rel() {
    pos := p_tokpos
    left := parse_cat()
    for REL_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_cat()
        left = Node(["binop", pos, p_endpos-pos, left, op, right])
    }
    return left
}

func parse_and() {
    pos := p_tokpos
    left := parse_rel()
    for p_tok == "&&" {
        op := p_tok
        scan()
        right := parse_rel()
        left = Node(["binop", pos, p_endpos-pos, left, op, right])
    }
    return left
}

parse_expr = func() {
    pos := p_tokpos
    left := parse_and()
    for p_tok == "||" {
        op := p_tok
        scan()
        right := parse_and()
        left = Node(["binop", pos, p_endpos-pos, left, op, right])
    }
    return left
}

parse_block, parse_body := nil, nil

func check_new_id(check_exist, name, tail, args) {
    if check_exist {
        v := find_var(name)
        if v {
            if v[7] {
                errorf("shadowing of constant is prohibited, you need to change the name '%s'", name)
            } else {
                errorf("shadowing of variable is prohibited, you need to change the name '%s'", name)
            }
        }
    }
    if RESERVED[name] {
        errorf("name '%s' is reserved", name)
    }
    if tail {
        errorf("unexpected tail after '%s'", name)
    }
    if args {
        errorf("unexpected args after '%s'", name)
    }
}

func parse_set_or_call() {
    pos := p_tokpos
    name := p_lit
    id, call := parse_id()
    if call {
        if !find_var(name) {
            errorf("undeclared variable '%s'", name)
        }
        return Node(["call", pos, p_endpos-pos, id])
    }
    if p_tok == "+=" {
        if !find_var(name) {
            errorf("undeclared variable '%s'", name)
        }
        scan()
        expr := parse_add()
        return Node(["inc", pos, p_endpos-pos, id, expr])
    }
    if p_tok == "-=" {
        if !find_var(name) {
            errorf("undeclared variable '%s'", name)
        }
        scan()
        expr := parse_add()
        return Node(["dec", pos, p_endpos-pos, id, expr])
    }
    left := List([id])
    for p_tok == "," {
        scan()
        expect("id")
        id, call = parse_id()
        if call {
            errorf("unexpected call")
        }
        left[#left+1] = id
    }
    if p_tok == "=" {
        for _, _id in ipairs(left) {
            name = _id[4]
            v := find_var(name)
            if !v {
                errorf("undeclared variable '%s'", name)
            }
            if v[7] {
                errorf("cannot assign to '%s' (declared const)", name)
            }
        }
        scan()
        right := List([])
        for {
            right[#right+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
        return Node(["set", pos, p_endpos-pos, left, right])
    }
    if p_tok == ":=" {
        allow := false
        for _, _id in ipairs(left) {
            name = _id[4]
            check_new_id(false, name, _id[5], _id[6])
            v, level := find_var(name)
            if !v {
                allow = true
            } else if v[7] {
                errorf("shadowing of constant is prohibited, you need to change the name '%s'", name)
            } else if level != p_level {
                errorf("shadowing of variable is prohibited, you need to change the name '%s'", name)
            }
        }
        if !allow {
            errorf("no new variables on left side of ':='")
        }
        scan()
        right := List([])
        for {
            right[#right+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
        for _, v in ipairs(left) {
            p_vars[v[4]] = v
        }
        return Node(["let", pos, p_endpos-pos, left, right])
    }
    expect("=")
}

parse_if := nil

func continue_parse_if(pos, left, right) {
    expr := parse_expr()
    body := parse_block()
    else_body := false
    if p_tok == "else" {
        scan()
        if p_tok == "if" {
            else_body = parse_if()
        } else {
            else_body = parse_block()
        }
    }
    return Node(["if", pos, p_endpos-pos, expr, body, else_body, left, right])
}

parse_if = func() {
    pos := p_tokpos
    skip("if")
    if p_tok != "id" {
        return continue_parse_if(pos)
    }
    id := parse_id()
    id_name := id[4]
    vars := nil
    left := nil
    switch p_tok {
    case ":=":
        check_new_id(true, id_name, id[5], id[6])
        vars = {[id_name]: id}
        left = List([id])
        scan()
    case ",":
        check_new_id(true, id_name, id[5], id[6])
        vars = {[id_name]: id}
        left = List([id])
        for p_tok == "," {
            scan()
            expect("id")
            name := p_lit
            check_new_id(true, name)
            next_id := Node(["id", p_tokpos, #name, name, false, false])
            left[#left+1] = next_id
            if vars[name] {
                errorf("re-declaring variable '%s'", name)
            }
            vars[name] = next_id
            scan()
        }
        skip(":=")
    default:
        if !find_var(id_name) {
            errorf("undeclared variable '%s'", id_name)
        }
        p_left = id
        return continue_parse_if(pos)
    }
    right := List([])
    for {
        right[#right+1] = parse_expr()
        if p_tok != "," {
            break
        }
        scan()
    }
    skip(";")
    open_scope(vars)
    node := continue_parse_if(pos, left, right)
    close_scope()
    return node
}

func parse_switch() {
    pos := p_tokpos
    skip("switch")
    expr := false
    cases := List([])
    if p_tok == "{" {
        scan()
        for p_tok == "case" {
            scan()
            case_expr := parse_expr()
            skip(":")
            body := parse_body()
            cases[#cases+1] = Node(["case", pos, p_endpos-pos, false, case_expr, body])
        }
    } else {
        expr = parse_expr()
        skip("{")
        expect("case")
        for p_tok == "case" {
            scan()
            list := List([])
            for {
                list[#list+1] = parse_expr()
                if p_tok != "," {
                    break
                }
                scan()
            }
            case_expr := false
            if p_tok == ";" {
                scan()
                case_expr = parse_expr()
            }
            skip(":")
            body := parse_body()
            cases[#cases+1] = Node(["case", pos, p_endpos-pos, list, case_expr, body])
        }
    }
    _default := false
    if p_tok == "default" {
        scan()
        skip(":")
        _default = parse_body()
    }
    skip("}")
    return Node(["switch", pos, p_endpos-pos, expr, cases, _default])
}

func parse_for() {
    pos := p_tokpos
    p_looplevel += 1
    skip("for")
    if p_tok == "{" {
        body := parse_block(nil, true)
        return Node(["for", pos, p_endpos-pos, false, body])
    }
    if p_tok != "id" {
        expr := parse_expr()
        body := parse_block(nil, true)
        return Node(["for", pos, p_endpos-pos, expr, body])
    }
    id := parse_id()
    id_name := id[4]
    ids := nil
    vars := nil
    switch p_tok {
    case ":=":
        check_new_id(true, id_name, id[5], id[6])
        vars = {[id_name]: id}
        scan()
        from := parse_expr()
        skip(",")
        to := parse_expr()
        by := nil
        if p_tok == "," {
            scan()
            by = parse_expr()
        }
        body := parse_block(vars, true)
        return Node(["for_to", pos, p_endpos-pos, id, from, to, by || false, body])
    case ",":
        check_new_id(true, id_name, id[5], id[6])
        vars = {[id_name]: id}
        ids = List([id])
        for p_tok == "," {
            scan()
            expect("id")
            name := p_lit
            check_new_id(true, name)
            next_id := Node(["id", p_tokpos, #name, name, false, false])
            ids[#ids+1] = next_id
            if vars[name] {
                errorf("re-declaring variable '%s'", name)
            }
            vars[name] = next_id
            scan()
        }
        skip("in")
    case "in":
        check_new_id(true, id_name, id[5], id[6])
        vars = {[id_name]: id}
        ids = List([id])
        scan()
    default:
        p_left = id
        expr := parse_expr()
        if !find_var(id_name) {
            errorf("undeclared variable '%s'", id_name)
        }
        body := parse_block(nil, true)
        return Node(["for", pos, p_endpos-pos, expr, body])
    }
    ins := List([])
    ins[#ins+1] = parse_expr()
    if p_tok == "," {
        scan()
        ins[#ins+1] = parse_expr()
    }
    if p_tok == "," {
        scan()
        ins[#ins+1] = parse_expr()
    }
    body := parse_block(vars, true)
    return Node(["for_in", pos, p_endpos-pos, ids, ins, body])
}

func parse_return() {
    pos := p_tokpos
    skip("return")
    list := List([])
    if p_tok != "}" {
        for {
            list[#list+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
    }
    if p_tok && p_tok != "case" && p_tok != "default" {
        expect("}")
    }
    return Node(["return", pos, p_endpos-pos, list])
}

func parse_break() {
    pos := p_tokpos
    assert(p_looplevel > 0, "no loop to break")
    skip("break")
    expr := false
    if p_tok == "if" {
        scan()
        expr = parse_expr()
    }
    expect("}")
    return Node(["break", pos, 5, expr])
}

func parse_continue() {
    pos := p_tokpos
    assert(p_looplevel > 0, "no loop to continue")
    skip("continue")
    expect("}")
    p_continue[p_looplevel] = true
    return Node(["continue", pos, 8])
}

func parse_const_item() {
    name := p_lit
    if RESERVED[name] {
        errorf("name '%s' is reserved", name)
    }
    if v := find_var(name); v {
        if v[7] {
            errorf("shadowing of constant is prohibited, you need to change the name '%s'", name)
        } else {
            errorf("shadowing of variable is prohibited, you need to change the name '%s'", name)
        }
    }
    id := Node(["id", p_tokpos, #name, name, false, false, nil])
    scan()
    skip("=")
    if !LITERALS[p_tok] {
        errorf("expected value")
    }
    id[7] = Node(["value", p_tokpos, #p_lit, p_val])
    p_vars[name] = id
    scan()
    return id
}

func parse_const() {
    pos := p_tokpos
    skip("const")
    if p_tok == "id" {
        list := List([parse_const_item()])
        return Node(["const", pos, p_endpos-pos, list])
    }
    if p_tok == "(" {
        scan()
        list := List([])
        for p_tok == "id" {
            list[#list+1] = parse_const_item()
            if p_tok == ";" {
                scan()
            }
        }
        skip(")")
        return Node(["const", pos, p_endpos-pos, list])
    }
    expect("id")
}

func parse_params() {
    pos := p_tokpos
    skip("(")
    list := List([])
    for {
        if p_tok == "..." {
            id := Node(["param", p_tokpos, 3, "..."])
            list[#list+1] = id
            p_vars["..."] = id
            scan()
            break
        }
        if p_tok != "id" {
            break
        }
        id := Node(["param", p_tokpos, #p_lit, p_lit])
        list[#list+1] = id
        if p_vars[p_lit] {
            errorf("parameter '%s' is already declared", p_lit)
        }
        p_vars[p_lit] = id
        scan()
        if p_tok != "," {
            break
        }
        scan()
    }
    skip(")")
    return Node(["params", pos, p_endpos-pos, list])
}

parse_func = func(lambda) {
    pos := p_tokpos
    name := false
    receiver := false
    vars := nil
    skip("func")
    if !lambda {
        if p_tok == "(" {
            receiver_pos := p_tokpos
            scan()
            expect("id")
            receiver_name := p_lit
            scan()
            expect("id")
            receiver_type := p_lit
            id := find_var(receiver_type)
            if !id {
                errorf("undeclared variable '%s'", receiver_type)
            }
            if id[7] {
                errorf("'%s' is a constant", receiver_type)
            }
            scan()
            skip(")")
            receiver = Node(["receiver", receiver_pos, p_endpos-receiver_pos, receiver_name, receiver_type])
            vars = {
                ["self"]: Node(["id", 0, 0, "self", false, false]),
                [receiver_name]: Node(["id", 0, 0, "receiver_name", false, false]),
            }
        }
        expect("id")
        name = p_lit
        scan()
        p_vars[name] = {} // hack for recursion
    }
    open_scope(vars)
    params := parse_params()
    body := parse_block()
    close_scope()
    node := Node(["func", pos, p_endpos-pos, name, params, body, receiver])
    if !lambda {
        p_vars[name] = node
    }
    return node
}

func parse_statement() {
    switch p_tok {
    case "id":
        return parse_set_or_call()
    case "func":
        return parse_func()
    case "if":
        return parse_if()
    case "{":
        return parse_block()
    case "for":
        return parse_for()
    case "return":
        return parse_return()
    case "break":
        return parse_break()
    case "continue":
        return parse_continue()
    case "switch":
        return parse_switch()
    case "const":
        return parse_const()
    case ";":
        scan()
        return Node(["nop", p_curpos, 1])
    }
    return nil
}

parse_body = func(vars) {
    open_scope(vars)
    body := List([])
    for {
        stmt := parse_statement()
        if stmt == nil {
            break
        }
        body[#body+1] = stmt
    }
    close_scope()
    return body
}

parse_block = func(vars, loop) {
    pos := p_tokpos
    skip("{")
    body := parse_body(vars)
    skip("}")
    if loop && p_continue[p_looplevel] {
        body[#body+1] = Node(["label", 0, 0, "continue"])
        p_continue[p_looplevel] = false
        p_looplevel -= 1
    }
    return Node(["block", pos, p_endpos-pos, body])
}

func parse_module(src, path, vars) {
    p_path = path
    p_src = src
    p_line = 1
    p_curpos = 0
    p_tokpos = 0
    p_endpos = 0
    p_chr = nil
    p_tok = nil
    p_lit = ""
    p_val = nil
    p_comments = List([])
    p_vars = {_G: ["id", 0, 0, "_G", false, false]}
    p_level = 1
    p_scope = List([p_vars])
    p_continue = List([])
    p_looplevel = 0
    p_curpos += 1; p_chr = string_byte(p_src, p_curpos)
    scan()
    pos := p_tokpos
    body := parse_body(vars)
    module := Node(["module", pos, p_endpos-pos, body, p_comments])
    if p_tok != nil {
        errorf("unexpected '%s'", p_tok)
    }
    return module
}

v_res := []
v_level := 0
LUA_OPS := setmetatable({
    "!"  : "not ",
    "&&" : "and",
    "||" : "or",
    "!=" : "~=",
}, {
    __index: func(t, k) {
        return k
    },
})

func space() {
    return string_rep("    ", v_level)
}

func emit(s) {
    v_res[#v_res+1] = s
}

emit_expr := nil

func emit_field(node) {
    name := node[5]
    if args := node[4]; args {
        if node[6] {
            emit(":" .. name)
        } else {
            if KEYWORDS[name] || RESERVED[name] {
                emit("[\"" .. name .. "\"]")
            } else {
                emit("." .. name)
            }
        }
        emit("(")
        if #args > 0 {
            for _, v in ipairs(args) {
                emit_expr(v)
                emit(", ")
            }
            v_res[#v_res] = ""
        }
        emit(")")
    } else {
        if KEYWORDS[name] || RESERVED[name] {
            emit("[\"" .. name .. "\"]")
        } else {
            emit("." .. name)
        }
    }
}

func emit_index(node) {
    emit("[")
    emit_expr(node[4])
    emit("]")
}

func emit_value(node) {
    v := node[4]
    if type(v) == "string" {
        tail := node[5]
        if tail {
            emit("(\"" .. v .. "\")")
            for _, _v in ipairs(tail) {
                if _v[1] == "field" {
                    emit_field(_v)
                } else {
                    emit_index(_v)
                }
            }
        } else {
            emit("\"" .. v .. "\"")
        }
    } else {
        emit(tostring(v))
    }
}

func emit_id(node) {
    if _const := node[7]; _const && _const[1] == "value" {
        emit_value(_const)
        return
    }
    emit(node[4])
    if args := node[6]; args {
        emit("(")
        if #args > 0 {
            for _, v in ipairs(args) {
                emit_expr(v)
                emit(", ")
            }
            v_res[#v_res] = ""
        }
        emit(")")
    }
    if tail := node[5]; tail {
        for _, v in ipairs(tail) {
            if v[1] == "field" {
                emit_field(v)
            } else {
                emit_index(v)
            }
        }
    }
}

func emit_pair(node) {
    key := node[4]
    switch key[1] {
    case "id"; !key[5] && !key[6]:
        name := key[4]
        if KEYWORDS[name] || RESERVED[name] {
            emit("[\"")
            emit_expr(key)
            emit("\"]")
        } else {
            emit_expr(key)
        }
    case "index":
        emit_index(key)
    default:
        emit("[")
        emit_expr(key)
        emit("]")
    }
    emit(" = ")
    emit_expr(node[5])
}

func emit_table(node) {
    if #node[4] == 0 {
        emit("{}")
        return
    }
    emit("{\n")
    v_level += 1
    for _, v in ipairs(node[4]) {
        emit(space())
        if v[1] == "pair" {
            emit_pair(v)
            emit(";\n")
        } else {
            emit_expr(v)
            emit(",\n")
        }
    }
    v_level -= 1
    emit(space() .. "}")
}

func emit_list(node) {
    emit("{")
    if list := node[4]; #list > 0 {
        for _, v in ipairs(list) {
            emit_expr(v)
            emit(", ")
        }
        v_res[#v_res] = ""
    }
    emit("}")
}

func emit_paren(node) {
    emit("(")
    emit_expr(node[4])
    emit(")")
}

func emit_unop(node) {
    if op := LUA_OPS[node[4]]; op != "+" {
        emit(op)
    }
    emit_expr(node[5])
}

func emit_binop(node) {
    emit_expr(node[4])
    emit(" " .. LUA_OPS[node[5]] .. " ")
    emit_expr(node[6])
}

emit_func := nil

emit_expr = func(node) {
    switch node[1] {
    case "id":
        emit_id(node)
    case "binop":
        emit_binop(node)
    case "unop":
        emit_unop(node)
    case "paren":
        emit_paren(node)
    case "value":
        emit_value(node)
    case "table":
        emit_table(node)
    case "list":
        emit_list(node)
    case "func":
        emit_func(node, true)
    case "vararg":
        emit("...")
    default:
        errorf("unknown node type: '%s'", node[1])
    }
}

emit_stmt := nil

func emit_body(node, skip_break) {
    v_level += 1
    for _, v in ipairs(node) {
        emit_stmt(v, skip_break)
    }
    v_level -= 1
}

func emit_block(node, skip_break) {
    emit_body(node[4], skip_break)
}

func emit_call(node) {
    emit(space())
    emit_id(node[4])
    emit("\n")
}

func emit_set(node) {
    emit(space())
    for _, v in ipairs(node[4]) {
        emit_id(v)
        emit(", ")
    }
    v_res[#v_res] = " = "
    for _, v in ipairs(node[5]) {
        emit_expr(v)
        emit(", ")
    }
    v_res[#v_res] = "\n"
}

func emit_inc(node) {
    emit(space())
    emit_id(node[4])
    emit(" = ")
    emit_id(node[4])
    emit(" + ")
    emit_expr(node[5])
    emit("\n")
}

func emit_dec(node) {
    emit(space())
    emit_id(node[4])
    emit(" = ")
    emit_id(node[4])
    emit(" - ")
    emit_expr(node[5])
    emit("\n")
}

func emit_let(node) {
    emit(space() .. "local ")
    for _, v in ipairs(node[4]) {
        emit_id(v)
        emit(", ")
    }
    v_res[#v_res] = " = "
    for _, v in ipairs(node[5]) {
        emit_expr(v)
        emit(", ")
    }
    v_res[#v_res] = "\n"
}

func emit_if(node) {
    if left := node[7]; left {
        right := node[8]
        emit(space() .. "local ")
        for _, v in ipairs(left) {
            emit(v[4])
            emit(", ")
        }
        v_res[#v_res] = " = "
        for _, v in ipairs(right) {
            emit_expr(v)
            emit(", ")
        }
        v_res[#v_res] = "\n"
    }
    emit(space() .. "if ")
    emit_expr(node[4])
    emit(" then\n")
    emit_block(node[5])
    _else := node[6]
    for _else {
        emit(space() .. "else")
        if _else[1] == "if" {
            emit("if ")
            emit_expr(_else[4])
            emit(" then\n")
            emit_block(_else[5])
            _else = _else[6]
        } else {
            emit("\n")
            emit_block(_else)
            _else = nil
        }
    }
    emit(space() .. "end\n")
}

func emit_switch(node) {
    if expr := node[4]; expr {
        emit(space() .. "local case = ")
        emit_expr(expr)
        emit("\n" .. space())
        for _, _case in ipairs(node[5]) {
            emit("if ")
            case_exp := _case[5]
            if case_exp {
                emit("(")
            }
            for _, item in ipairs(_case[4]) {
                emit("case == ")
                if item[1] == "binop" {
                    emit("(")
                    emit_expr(item)
                    emit(")")
                } else {
                    emit_expr(item)
                }
                emit(" or ")
            }
            if case_exp {
                v_res[#v_res] = ") and ("
                emit_expr(case_exp)
                emit(")")
            } else {
                v_res[#v_res] = ""
            }
            emit(" then\n")
            emit_body(_case[6])
            emit(space() .. "else")
        }
        _default := node[6]
        if _default {
            emit("\n")
            emit_body(_default)
        } else {
            v_res[#v_res] = ""
        }
        emit(space() .. "end\n")
    } else {
        emit(space())
        for _, _case in ipairs(node[5]) {
            emit("if ")
            emit_expr(_case[5])
            emit(" then\n")
            emit_body(_case[6])
            emit(space() .. "else")
        }
        _default := node[6]
        if _default {
            emit("\n")
            emit_body(_default)
        } else {
            v_res[#v_res] = ""
        }
        emit(space() .. "end\n")
    }
}

func emit_for(node) {
    expr, block := node[4], node[5]
    body := block[4]
    if !expr && #body > 0 {
        last := body[#body]
        if last[1] == "break" {
            break_expr := last[4]
            if break_expr {
                emit(space() .. "repeat\n")
                emit_block(block, true)
                emit(space() .. "until ")
                emit_expr(break_expr)
                emit("\n")
                return
            }
        }
    }
    emit(space() .. "while ")
    if expr {
        emit_expr(expr)
    } else {
        emit("true")
    }
    emit(" do\n")
    emit_block(block)
    emit(space() .. "end\n")
}

func emit_for_to(node) {
    emit(space() .. "for ")
    emit_id(node[4])
    emit(" = ")
    emit_expr(node[5])
    emit(", ")
    emit_expr(node[6])
    if step := node[7]; step {
        emit(", ")
        emit_expr(step)
    }
    emit(" do\n")
    emit_block(node[8])
    emit(space() .. "end\n")
}

func emit_for_in(node) {
    emit(space() .. "for ")
    for _, v in ipairs(node[4]) {
        emit_id(v)
        emit(", ")
    }
    v_res[#v_res] = " in "
    for _, v in ipairs(node[5]) {
        emit_expr(v)
        emit(", ")
    }
    v_res[#v_res] = " do\n"
    emit_block(node[6])
    emit(space() .. "end\n")
}

func emit_return(node) {
    emit(space() .. "return")
    if list := node[4]; list {
        emit(" ")
        for _, v in ipairs(list) {
            emit_expr(v)
            emit(", ")
        }
        v_res[#v_res] = ""
    }
    emit("\n")
}

func emit_break(node) {
    if expr := node[4]; expr {
        emit(space() .. "if ")
        emit_expr(expr)
        emit(" then\n")
        v_level = v_level + 1
        emit(space() .. "break\n")
        v_level = v_level - 1
        emit(space() .. "end\n")
    } else {
        emit(space() .. "break\n")
    }
}

func emit_continue(node) {
    emit(space() .. "goto continue\n")
}

func emit_label(node) {
    emit(space() .. "::" .. node[4] .. "::\n")
}

func emit_params(node) {
    t := {}
    for _, v in ipairs(node[4]) {
        t[#t+1] = v[4]
    }
    emit("("..table_concat(t, ", ")..")\n")
}

emit_func = func(node, lambda) {
    receiver := node[7]
    if lambda {
        emit("function")
        emit_params(node[5])
    } else if receiver {
        emit(space() .. "function " .. receiver[5] .. ":" .. node[4])
        emit_params(node[5])
        v_level += 1
        emit(space() .. "local " .. receiver[4] .. " = self\n")
        v_level -= 1
    } else {
        emit(space() .. "local function " .. node[4])
        emit_params(node[5])
    }
    emit_block(node[6])
    emit(space() .. "end")
    if !lambda {
        emit("\n")
    }
}

func emit_nop(node) {
    v_res[#v_res] = ";\n"
}

emit_stmt = func(node, skip_break) {
    switch node[1] {
    case "call":
        emit_call(node)
    case "set":
        emit_set(node)
    case "inc":
        emit_inc(node)
    case "dec":
        emit_dec(node)
    case "let":
        emit_let(node)
    case "if":
        emit_if(node)
    case "switch":
        emit_switch(node)
    case "block":
        emit(space() .. "do\n")
        emit_block(node)
        emit(space() .. "end\n")
    case "for":
        emit_for(node)
    case "for_to":
        emit_for_to(node)
    case "for_in":
        emit_for_in(node)
    case "return":
        emit_return(node)
    case "break":
        if !skip_break {
            emit_break(node)
        }
    case "continue":
        emit_continue(node)
    case "label":
        emit_label(node)
    case "func":
        emit_func(node)
    case "nop":
        emit_nop(node)
    case "const":
        // skip
    default:
        errorf("unknown node type: %s", node[1])
    }
}

func emit_module(node, level) {
    v_res = []
    v_level = level || 0
    for _, v in ipairs(node[4]) {
        emit_stmt(v)
    }
    return table_concat(v_res)
}

{
    if fn := _G.arg[1]; fn {
        os, io, pcall, print, load := _G.os, _G.io, _G.pcall, _G.print, _G.loadstring || _G.load
        src := io::open(fn, "r").read("*a")
        r, m := pcall(parse_module, src, fn)
        if r {
            res := emit_module(m, 0)
            if out := _G.arg[2]; out {
                f := io::open(out, "w")
                f.write(res)
                f.close()
                print(os::clock())
            } else {
                f, err := load(res)
                if err {
                    print(err)
                    os::exit(1)
                }
                f()
            }
        } else {
            print(m)
            os::exit(1)
        }
    }
}

return {
    Node: Node,
    nodes: nodes,
    parse_module: parse_module,
    emit_module: emit_module,
}
