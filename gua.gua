// MIT License

// Copyright (c) 2021 tsukanov-as

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

_G::setfenv(1, {_G: _G})

string_byte := _G.string.byte
string_sub := _G.string.sub
string_rep := _G.string.rep
string_format := _G.string.format
string_find := _G.string.find
table_concat := _G.table.concat
table_sort := _G.table.sort
tonumber := _G.tonumber
assert := _G.assert
setmetatable := _G.setmetatable
pairs := _G.pairs
ipairs := _G.ipairs
tostring := _G.tostring
error := _G.error
type := _G.type

Type := {
    __call: func(self, t) {
        if self.init {
            t = self.init(t)
        }
        return setmetatable(t, self)
    },
}
setmetatable(Type, Type)

Hex := Type.{
    __tostring: func(t) {
        return string_format("0x%02X", t[1])
    },
}

Raw := Type.{
    __tostring: func(t) {
        s := t[1]
        i := 0
        x := nil
        for true {
            x = string_rep("=", i)
            if !string_find(s, "[" .. x .. "[", 1, true)
                && !string_find(s, "]" .. x .. "]", 1, true) {
                break
            }
            i = i + 1
        }
        return string_format(" [%s[%s]%s]", x, s, x)
    },
}

List := Type.{
    __tostring: func(t) {
        res := {}
        for i, v in ipairs(t) {
            if type(v) == "string" {
                res[i] = string_format("%q", v)
            } else {
                res[i] = tostring(v)
            }
        }
        return "{" .. table_concat(res, ", ") .. "}"
    },
}

Set := Type.{
    __tostring: func(t) {
        res := {}
        for k in pairs(t) {
            if type(k) == "string" {
                res[#res+1] = string_format("%q", k)
            } else {
                res[#res+1] = tostring(k)
            }
        }
        table_sort(res)
        return "{" .. table_concat(res, ", ") .. "}"
    },
    init: func(self, t) {
        set := {}
        for _, v in ipairs(t) {
            set[v] = v
        }
        return set
    },
}

Fields := Type.{
    __tostring: func(t) {
        res := {}
        for i, v in ipairs(t) {
            res[#res+1] = string_format("%d:%q", i, v)
        }
        table_sort(res)
        return "{" .. table_concat(res, ", ") .. "}"
    },
    init: func(self, t) {
        fields := {}
        for i, v in ipairs(t) {
            fields[i] = v
            fields[v] = i
        }
        return fields
    },
}

nodes := {
    "module"   : Fields.["Type", "Pos", "Len", "Body", "Comments"],
    "value"    : Fields.["Type", "Pos", "Len", "Value"],
    "field"    : Fields.["Type", "Pos", "Len", "Args", "Name", "Dot", "Paren"],
    "index"    : Fields.["Type", "Pos", "Len", "Expr"],
    "id"       : Fields.["Type", "Pos", "Len", "Name", "Tail", "Args", "Const", "Paren"],
    "table"    : Fields.["Type", "Pos", "Len", "List"],
    "pair"     : Fields.["Type", "Pos", "Len", "Left", "Right"],
    "list"     : Fields.["Type", "Pos", "Len", "List"],
    "paren"    : Fields.["Type", "Pos", "Len", "Expr"],
    "unop"     : Fields.["Type", "Pos", "Len", "Op", "Expr"],
    "binop"    : Fields.["Type", "Pos", "Len", "Left", "Op", "Right"],
    "call"     : Fields.["Type", "Pos", "Len", "ID"],
    "set"      : Fields.["Type", "Pos", "Len", "Left", "Right"],
    "let"      : Fields.["Type", "Pos", "Len", "Left", "Right"],
    "inc"      : Fields.["Type", "Pos", "Len", "ID", "Expr"],
    "dec"      : Fields.["Type", "Pos", "Len", "ID", "Expr"],
    "if"       : Fields.["Type", "Pos", "Len", "Expr", "Then", "Else"],
    "block"    : Fields.["Type", "Pos", "Len", "Body"],
    "for"      : Fields.["Type", "Pos", "Len", "Expr", "Body"],
    "for_to"   : Fields.["Type", "Pos", "Len", "ID", "From", "Limit", "Step", "Body"],
    "for_in"   : Fields.["Type", "Pos", "Len", "IDs", "INs", "Body"],
    "return"   : Fields.["Type", "Pos", "Len", "List"],
    "break"    : Fields.["Type", "Pos", "Len", "Expr"],
    "continue" : Fields.["Type", "Pos", "Len"],
    "label"    : Fields.["Type", "Pos", "Len", "Name"],
    "func"     : Fields.["Type", "Pos", "Len", "Name", "Params", "Body", "Receiver", "Dot"],
    "nop"      : Fields.["Type", "Pos", "Len"],
    "vararg"   : Fields.["Type", "Pos", "Len"],
    "param"    : Fields.["Type", "Pos", "Len", "Name"],
    "params"   : Fields.["Type", "Pos", "Len", "List"],
    "switch"   : Fields.["Type", "Pos", "Len", "Expr", "Cases", "Default"],
    "case"     : Fields.["Type", "Pos", "Len", "List", "Expr", "Body"],
    "const"    : Fields.["Type", "Pos", "Len", "List"],
}

Node := Type.{
    __tostring: List.__tostring,
    __index: func(t, k) {
        if type(k) == "string" {
            _type := t[1]
            if k == "Type" {
                return _type
            }
            return t[nodes[_type][k]]
        }
        return nil
    },
}

KEYWORDS := Set.["break", "continue", "else", "false", "for", "func", "if", "in", "nil", "return", "true", "switch", "case", "default", "const"]
RESERVED := Set.["local", "function", "while", "do", "end", "repeat", "until", "and", "or", "not", "then", "elseif"]
LITERALS := Set.["str", "chr", "raw", "num", "true", "false", "nil"]
REL_OPS := Set.["==", "!=", "<", ">", "<=", ">="]
MUL_OPS := Set.["*", "/", "%"]
ADD_OPS := Set.["+", "-"]
UNR_OPS := Set.["+", "-", "!", "#"]

const (
    LF = 0x0A
    ALPHA = 1
    DIGIT = 2
    SPACE = 3
)

MAP := {
    '"': "str",
    '\'': "chr",
    '`': "raw",
}
HEX := {}
ALPHA_OR_DIGIT := {}
{
    byte, sub := string_byte, string_sub

    sym := "()[]{}*:;.,/+-=<>#%|&!^"
    for i := 1, #sym {
        MAP[byte(sym, i)] = sub(sym, i, i)
    }
    for i := 0x1, ' ' {
        MAP[i] = SPACE
    }
    for i := '0', '9' {
        MAP[i] = DIGIT; ALPHA_OR_DIGIT[i] = true
    }

    abc := "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    for i := 1, #abc {
        MAP[byte(abc, i)] = ALPHA; ALPHA_OR_DIGIT[byte(abc, i)] = true
    }

    hex := "ABCDEFabcdef0123456789"
    for i := 1, #hex {
        HEX[byte(hex, i)] = true
    }
}

// parser state
p_path := nil
p_src := nil
p_line := 1
p_curpos := 0
p_tokpos := 0 // current token pos
p_endpos := 0 // previous token end pos
p_chr := nil
p_tok := nil
p_lit := ""
p_val := nil
p_comments := List.[]
p_vars := {}
p_scope := {}
p_level := 0
p_skip_id_check := false
p_skipped_id_name := nil
p_continue := List.[]
p_looplevel := 0

func errorf(notef, ...) {
    if p_path {
        error(p_path .. ":" .. p_line .. ": " .. string_format(notef, ...), 2)
    } else {
        error(string_format(notef, ...) .. " in line " .. p_line, 2)
    }
}

// _scan(...) ?

func scan() {
    byte := string_byte
    src := p_src
    pos := p_curpos
    chr := p_chr
    tok := nil
    for {
        tok = MAP[chr]
        p_lit = ""
        p_val = nil
        p_endpos = pos
        for tok == SPACE {
            if chr == LF {
                p_line = p_line + 1
            }
            pos += 1; chr = byte(src, pos)
            tok = MAP[chr]
        }
        p_tokpos = pos
        switch tok {
        case ALPHA:
            AD := ALPHA_OR_DIGIT
            beg := pos
            for {
                pos += 1; chr = byte(src, pos);
                break if !AD[chr]
            }
            p_lit = string_sub(src, beg, pos-1)
            tok = KEYWORDS[p_lit] || "id"
            if tok == "true" {
                p_val = true
            } else if tok == "false" {
                p_val = false
            }
        case DIGIT:
            beg := pos
            base := 10
            if chr == '0' {
                pos += 1; chr = byte(src, pos)
                switch chr {
                case 'X', 'x':
                    pos += 1; chr = byte(src, pos)
                    beg = pos
                    if !HEX[chr] {
                        errorf("expected hex digit, found '%c'", chr)
                    }
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if !HEX[chr]
                    }
                    base = 16
                    if pos-beg > 8 {
                        errorf("integer greater than 32 bits", tok)
                    }
                case 'B', 'b':
                    pos += 1; chr = byte(src, pos)
                    beg = pos
                    if chr != '0' && chr != '1' {
                        errorf("expected bin digit, found '%c'", chr)
                    }
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if chr != '0' && chr != '1'
                    }
                    base = 2
                    if pos-beg > 32 {
                        errorf("integer greater than 32 bits", tok)
                    }
                }
            }
            if base == 10 {
                for MAP[chr] == DIGIT {
                    pos += 1; chr = byte(src, pos)
                }
                if chr == '.' {
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if MAP[chr] != DIGIT
                    }
                }
                if chr == 'E' || chr == 'e' {
                    pos += 1; chr = byte(src, pos)
                    if chr == '+' || chr == '-' {
                        pos += 1; chr = byte(src, pos)
                    }
                    if MAP[chr] != DIGIT {
                        errorf("expected digit, found '%s'", tok)
                    }
                    for {
                        pos += 1; chr = byte(src, pos)
                        break if MAP[chr] != DIGIT
                    }
                }
            }
            tok = "num"
            p_lit = string_sub(src, beg, pos-1)
            if base == 10 {
                p_val = tonumber(p_lit)
            } else {
                p_val = Hex.[tonumber(p_lit, base)]
            }
            if p_val == nil {
                errorf("malformed number '%s'", p_lit)
            }
        case "str":
            beg := pos
            for {
                pos += 1; chr = byte(src, pos)
                if chr == '\\' {
                    pos += 2; chr = byte(src, pos)
                }
                break if chr == '"' || chr == LF || chr == nil
            }
            if chr != '"' {
                errorf("expected \", found EOL")
            }
            p_lit = string_sub(src, beg+1, pos-1)
            p_val = p_lit
            pos += 1; chr = byte(src, pos)
        case "raw":
            beg := pos
            for {
                pos += 1; chr = byte(src, pos)
                if chr == LF {
                    p_line = p_line + 1
                }
                break if chr == '`' || chr == nil
            }
            if chr != '`' { errorf("expected `, found '%c'", chr) }
            p_lit = string_sub(src, beg+1, pos-1)
            p_val = Raw.[p_lit]
            pos += 1; chr = byte(src, pos)
        case "chr":
            beg := pos
            pos += 1; chr = byte(src, pos)
            if chr == '\\' {
                beg = pos
                pos += 1; chr = byte(src, pos)
            }
            pos += 1; chr = byte(src, pos)
            if chr != '\'' {
                errorf("expected ', found '%c'", chr)
            }
            p_lit = string_sub(src, beg+1, pos-1)
            p_val = Hex.[string_byte(p_lit)]
            pos += 1; chr = byte(src, pos)
        case ":":
            pos += 1; chr = byte(src, pos)
            if chr == '=' {
                tok = ":="
                pos += 1; chr = byte(src, pos)
            } else if chr == ':' {
                tok = "::"
                pos += 1; chr = byte(src, pos)
            }
        case "=":
            pos += 1; chr = byte(src, pos)
            if chr == '=' {
                tok = "=="
                pos += 1; chr = byte(src, pos)
            }
        case "+":
            pos += 1; chr = byte(src, pos)
            if chr == '=' {
                tok = "+="
                pos += 1; chr = byte(src, pos)
            }
        case "-":
            pos += 1; chr = byte(src, pos)
            if chr == '=' {
                tok = "-="
                pos += 1; chr = byte(src, pos)
            }
        case "/":
            pos += 1; chr = byte(src, pos)
            if chr == '/' {
                beg := pos
                for {
                    pos += 1; chr = byte(src, pos)
                    break if chr == LF || chr == nil
                }
                p_lit = string_sub(src, beg+1, pos-1)
                p_comments[p_line] = p_lit
                tok = "//"
            }
        case "<":
            pos += 1; chr = byte(src, pos)
            if chr == '=' {
                tok = "<="
                pos += 1; chr = byte(src, pos)
            }
        case ">":
            pos += 1; chr = byte(src, pos)
            if chr == '=' {
                tok = ">="
                pos += 1; chr = byte(src, pos)
            }
        case "&":
            pos += 1; chr = byte(src, pos)
            if chr == '&' {
                tok = "&&"
                pos += 1; chr = byte(src, pos)
            }
        case "|":
            pos += 1; chr = byte(src, pos)
            if chr == '|' {
                tok = "||"
                pos += 1; chr = byte(src, pos)
            }
        case "!":
            pos += 1; chr = byte(src, pos)
            if chr == '=' {
                tok = "!="
                pos += 1; chr = byte(src, pos)
            }
        case ".":
            pos += 1; chr = byte(src, pos)
            if chr == '.' {
                tok = ".."
                pos += 1; chr = byte(src, pos)
                if chr == '.' {
                    tok = "..."
                    pos += 1; chr = byte(src, pos)
                }
            } else if chr == '[' {
                tok = ".["
                pos += 1; chr = byte(src, pos)
            } else if chr == '{' {
                tok = ".{"
                pos += 1; chr = byte(src, pos)
            }
        case nil; chr != nil:
            errorf("unknown symbol '%c'", chr)
        default:
            pos += 1; chr = byte(src, pos)
        }
        break if tok != "//"
    }
    p_curpos, p_chr, p_tok = pos, chr, tok
    return p_tok
}

func expect(t, l) {
    if p_tok != t {
        str := nil
        if p_tok == "num" || p_tok == "str" || p_tok == "chr" || p_tok == "id" {
            str = p_lit
        } else {
            str = tostring(p_tok)
        }
        if p_path {
            error(string_format("%s:%d: expected '%s', found '%s'", p_path, p_line, tostring(t), str), l || 2)
        } else {
            error(string_format("expected '%s', found '%s' in line %d", tostring(t), str, p_line), l || 2)
        }
    }
}

func skip(t) {
    expect(t, 3)
    return scan()
}

func open_scope(vars) {
    p_vars = vars || {}
    p_level += 1
    p_scope[p_level] = p_vars
}

func close_scope() {
    p_level -= 1
    p_vars = p_scope[p_level]
}

func find_var(name) {
    if name == "_" {
        return nil
    }
    v := p_vars[name]
    i := p_level
    for v == nil && i > 1 {
        i -= 1
        v = p_scope[i][name]
    }
    return v, i
}

func assertf(expr, notef, ...) {
    if !expr {
        if p_path {
            error(p_path .. ":" .. p_line .. ": " .. string_format(notef, ...), 2)
        } else {
            error(string_format(notef, ...) .. " in line " .. p_line, 2)
        }
    }
    return expr
}

parse_expr := nil
parse_table, parse_list := nil, nil

func parse_tail(call) {
    tail, i := List.[], 0
    for true {
        pos := p_tokpos
        dot := (p_tok == ".")
        switch p_tok {
        case ".", "::":
            scan()
            if KEYWORDS[p_lit] == nil {
                expect("id")
            }
            name := p_lit
            args := false
            paren := false
            last := p_tokpos
            scan()
            switch p_tok {
            case "(":
                scan()
                args = List.[]
                for p_tok != ")" {
                    args[#args+1] = parse_expr()
                    if p_tok != "," {
                        break
                    }
                    scan()
                }
                last = p_tokpos
                skip(")")
                call = true
                paren = true
            case "str":
                args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
                last = p_tokpos
                scan()
                call = true
            case "chr":
                args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
                last = p_tokpos
                scan()
                call = true
                paren = true
            case ".{":
                args = List.[parse_table()]
                last = p_tokpos
                scan()
                call = true
            case ".[":
                args = List.[parse_list()]
                last = p_tokpos
                scan()
                call = true
            default:
                call = false
            }
            if args && dot && (KEYWORDS[name] || RESERVED[name]) {
                errorf("name '%s' cannot be used in a method call", name)
            }
            item := Node.["field", pos, last - pos, args || false, name, dot, paren]
            i += 1
            tail[i] = item
        case "[":
            scan()
            assertf(p_tok != "]", "expected expression, found ']'")
            expr := parse_expr()
            skip("]")
            i += 1
            tail[i] = Node.["index", pos, p_endpos-pos, expr]
        default:
            break
        }
    }
    return i > 0 && tail, call
}

func parse_id() {
    pos := p_tokpos
    name := p_lit
    _const := false
    assertf(!RESERVED[name], "name '%s' is reserved", name)
    if p_skip_id_check {
        p_skipped_id_name = name
        p_skip_id_check = false
    } else {
        id := assertf(find_var(name), "undeclared variable '%s'", name)
        _const = id[7]
    }
    call := false
    paren := false
    args, tail := false, false
    scan()
    if !_const {
        switch p_tok {
        case "(":
            scan()
            args = List.[]
            for p_tok != ")" {
                args[#args+1] = parse_expr()
                if p_tok != "," {
                    break
                }
                scan()
            }
            skip(")")
            call = true
            paren = true
        case "str":
            args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
            scan()
            call = true
        case "chr":
            args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
            scan()
            call = true
            paren = true
        case ".{":
            args = List.[parse_table()]
            call = true
        case ".[":
            args = List.[parse_list()]
            call = true
        }
        tail, call = parse_tail(call)
    }
    node := Node.["id", pos, p_endpos-pos, name, tail, args, _const, paren]
    return node, call
}

func parse_paren() {
    pos := p_tokpos
    skip("(")
    expr := parse_expr()
    skip(")")
    return Node.["paren", pos, p_endpos-pos, expr]
}

parse_table = func() {
    pos := p_tokpos
    list := List.[]
    scan() // skip "{" || ".{"
    for p_tok != "}" {
        key_pos := p_tokpos
        left := nil
        if p_tok == "id" || KEYWORDS[p_lit] {
            left = Node.["id", key_pos, #p_lit, p_lit, false, false]
            scan()
        } else if p_tok == "[" {
            scan()
            expr := parse_expr()
            skip("]")
            left = Node.["index", key_pos, p_endpos-key_pos, expr]
        } else {
            left = parse_expr()
        }
        expect(":")
        scan()
        right := parse_expr()
        list[#list+1] = Node.["pair", pos, p_endpos-pos, left, right]
        if p_tok != "," {
            break
        }
        scan()
    }
    skip("}")
    return Node.["table", pos, p_endpos-pos, list]
}

parse_list = func() {
    pos := p_tokpos
    list := List.[]
    scan() // skip "[" || ".["
    for p_tok != "]" {
        list[#list+1] = parse_expr()
        if p_tok != "," {
            break
        }
        scan()
    }
    skip("]")
    return Node.["list", pos, p_endpos-pos, list]
}

parse_func := nil

func parse_operand() {
    node := nil
    switch p_tok {
    case "str":
        pos, len, val := p_tokpos, #p_lit, p_val
        scan()
        tail := parse_tail()
        node = Node.["value", pos, len, val, tail]
    case "id":
        node = parse_id()
    case "(":
        node = parse_paren()
    case "{":
        node = parse_table()
    case "[":
        node = parse_list()
    case "func":
        node = parse_func(true)
    case "...":
        node = Node.["vararg", p_tokpos, 3]
        scan()
    default:
        if LITERALS[p_tok] {
            node = Node.["value", p_tokpos, #p_lit, p_val]
            scan()
        } else {
            errorf("expected operand, found '%s'", p_tok)
        }
    }
    return node
}

func parse_pow() {
    pos := p_tokpos
    left := parse_operand()
    for p_tok == "^" {
        scan()
        right := parse_operand()
        left = Node.["binop", pos, p_endpos-pos, left, "^", right]
    }
    return left
}

func parse_unary() {
    pos := p_tokpos
    expr := nil
    if UNR_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_pow()
        expr = Node.["unop", pos, p_endpos-pos, op, right]
    } else {
        expr = parse_pow()
    }
    return expr
}

func parse_mul() {
    pos := p_tokpos
    left := parse_unary()
    for MUL_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_unary()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

func parse_add() {
    pos := p_tokpos
    left := parse_mul()
    for ADD_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_mul()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

func parse_cat() {
    pos := p_tokpos
    left := parse_add()
    for p_tok == ".." {
        scan()
        right := parse_add()
        left = Node.["binop", pos, p_endpos-pos, left, "..", right]
    }
    return left
}

func parse_rel() {
    pos := p_tokpos
    left := parse_cat()
    for REL_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_cat()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

func parse_and() {
    pos := p_tokpos
    left := parse_rel()
    for p_tok == "&&" {
        op := p_tok
        scan()
        right := parse_rel()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

parse_expr = func() {
    pos := p_tokpos
    left := parse_and()
    for p_tok == "||" {
        op := p_tok
        scan()
        right := parse_and()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

parse_block, parse_body := nil, nil

func parse_set_or_call() {
    pos := p_tokpos
    name := p_lit
    p_skip_id_check = true
    id, call := parse_id()
    if call {
        assertf(find_var(name), "undeclared variable '%s'", name)
        return Node.["call", pos, p_endpos-pos, id]
    }
    if p_tok == "+=" {
        assertf(find_var(name), "undeclared variable '%s'", name)
        scan()
        expr := parse_add()
        return Node.["inc", pos, p_endpos-pos, id, expr]
    }
    if p_tok == "-=" {
        assertf(find_var(name), "undeclared variable '%s'", name)
        scan()
        expr := parse_add()
        return Node.["dec", pos, p_endpos-pos, id, expr]
    }
    left := List.[id]
    for p_tok == "," {
        scan()
        expect("id")
        p_skip_id_check = true
        id, call = parse_id()
        assertf(!call, "unexpected call")
        left[#left+1] = id
    }
    if p_tok == "=" {
        for _, _id in ipairs(left) {
            name = _id[4]
            v := assertf(find_var(name), "undeclared variable '%s'", name)
            assertf(!v[7], "cannot assign to '%s' (declared const)", name)
        }
        scan()
        right := List.[]
        for true {
            right[#right+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
        return Node.["set", pos, p_endpos-pos, left, right]
    }
    if p_tok == ":=" {
        allow := false
        for _, _id in ipairs(left) {
            assertf(!_id[5], "unexpected tail")
            assertf(!_id[6], "unexpected call")
            assertf(!_id[7], "unexpected self")
            v, level := find_var(_id[4])
            if !v {
                allow = true
            } else if level != p_level || v[7] {
                errorf("variable shadowing is prohibited, you need to change the name '%s'", p_skipped_id_name)
            }
        }
        assertf(allow, "no new variables on left side of ':='")
        scan()
        right := List.[]
        for {
            right[#right+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
        for _, v in ipairs(left) {
            p_vars[v[4]] = v
        }
        return Node.["let", pos, p_endpos-pos, left, right]
    }
    expect("=")
}

func parse_if() {
    pos := p_tokpos
    skip("if")
    expr := parse_expr()
    body := parse_block()
    else_body := false
    if p_tok == "else" {
        scan()
        if p_tok == "if" {
            else_body = parse_if()
        } else {
            else_body = parse_block()
        }
    }
    return Node.["if", pos, p_endpos-pos, expr, body, else_body]
}

func parse_switch() {
    pos := p_tokpos
    skip("switch")
    expr := false
    cases := List.[]
    if p_tok == "{" {
        scan()
        for p_tok == "case" {
            scan()
            case_expr := parse_expr()
            skip(":")
            body := parse_body()
            cases[#cases+1] = Node.["case", pos, p_endpos-pos, false, case_expr, body]
        }
    } else {
        expr = parse_expr()
        skip("{")
        expect("case")
        for p_tok == "case" {
            scan()
            list := List.[]
            for true {
                list[#list+1] = parse_expr()
                if p_tok != "," {
                    break
                }
                scan()
            }
            case_expr := false
            if p_tok == ";" {
                scan()
                case_expr = parse_expr()
            }
            skip(":")
            body := parse_body()
            cases[#cases+1] = Node.["case", pos, p_endpos-pos, list, case_expr, body]
        }
    }
    _default := false
    if p_tok == "default" {
        scan()
        skip(":")
        _default = parse_body()
    }
    skip("}")
    return Node.["switch", pos, p_endpos-pos, expr, cases, _default]
}

func parse_for() {
    pos := p_tokpos
    p_looplevel += 1
    skip("for")
    if p_tok == "{" {
        body := parse_block(nil, true)
        return Node.["for", pos, p_endpos-pos, false, body]
    }
    p_skip_id_check = true
    expr := parse_expr()
    if p_tok == "{" || expr[1] != "id" || expr[5] || expr[6] {
        assertf(find_var(p_skipped_id_name), "undeclared variable '%s'", p_skipped_id_name)
        body := parse_block(nil, true)
        return Node.["for", pos, p_endpos-pos, expr, body]
    }
    vars := {[expr[4]]: expr}
    if p_tok == ":=" {
        assertf(!find_var(p_skipped_id_name), "variable shadowing is prohibited, you need to change the name '%s'", p_skipped_id_name)
        scan()
        from := parse_expr()
        skip(",")
        to := parse_expr()
        by := nil
        if p_tok == "," {
            scan()
            by = parse_expr()
        }
        body := parse_block(vars, true)
        return Node.["for_to", pos, p_endpos-pos, expr, from, to, by || false, body]
    }
    assertf(!find_var(p_skipped_id_name), "variable shadowing is prohibited, you need to change the name '%s'", p_skipped_id_name)
    ids := List.[expr]
    for p_tok == "," {
        scan()
        expect("id")
        name := p_lit
        assertf(!RESERVED[name], "name '%s' is reserved", name)
        assertf(!find_var(name), "variable shadowing is prohibited, you need to change the name '%s'", name)
        id := Node.["id", p_tokpos, #name, name, false, false]
        ids[#ids+1] = id
        assertf(vars[name] == nil, "re-declaring variable '%s'", name)
        vars[name] = id
        scan()
    }
    expect("in")
    ins := List.[]
    scan()
    ins[#ins+1] = parse_expr()
    if p_tok == "," {
        scan()
        ins[#ins+1] = parse_expr()
    }
    if p_tok == "," {
        scan()
        ins[#ins+1] = parse_expr()
    }
    body := parse_block(vars, true)
    return Node.["for_in", pos, p_endpos-pos, ids, ins, body]
}

func parse_return() {
    pos := p_tokpos
    skip("return")
    list := List.[]
    if p_tok != "}" {
        for {
            list[#list+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
    }
    if p_tok && p_tok != "case" {
        expect("}")
    }
    return Node.["return", pos, p_endpos-pos, list]
}

func parse_break() {
    pos := p_tokpos
    assert(p_looplevel > 0, "no loop to break")
    skip("break")
    expr := false
    if p_tok == "if" {
        scan()
        expr = parse_expr()
    }
    expect("}")
    return Node.["break", pos, 5, expr]
}

func parse_continue() {
    pos := p_tokpos
    assert(p_looplevel > 0, "no loop to continue")
    skip("continue")
    expect("}")
    p_continue[p_looplevel] = true
    return Node.["continue", pos, 8]
}

func parse_const() {
    pos := p_tokpos
    skip("const")
    if p_tok == "id" {
        name := p_lit
        assertf(!RESERVED[name], "name '%s' is reserved", name)
        assertf(!find_var(name), "variable shadowing is prohibited, you need to change the name '%s'", name)
        id := Node.["id", p_tokpos, #name, name, false, false, nil]
        list := List.[id]
        scan()
        skip("=")
        assertf(LITERALS[p_tok], "expected value")
        id[7] = Node.["value", p_tokpos, #p_lit, p_val]
        p_vars[name] = id
        scan()
        return Node.["const", pos, p_endpos-pos, list]
    }
    if p_tok == "(" {
        scan()
        list := List.[]
        for p_tok == "id" {
            name := p_lit
            assertf(!RESERVED[name], "name '%s' is reserved", name)
            assertf(!find_var(name), "variable shadowing is prohibited, you need to change the name '%s'", name)
            id := Node.["id", p_tokpos, #name, name, false, false, nil]
            list[#list+1] = id
            scan()
            skip("=")
            assertf(LITERALS[p_tok], "expected value")
            id[7] = Node.["value", p_tokpos, #p_lit, p_val]
            p_vars[name] = id
            scan()
        }
        skip(")")
        return Node.["const", pos, p_endpos-pos, list]
    }
    expect("id")
}

func parse_params() {
    pos := p_tokpos
    skip("(")
    list := List.[]
    for true {
        if p_tok == "..." {
            id := Node.["param", p_tokpos, 3, "..."]
            list[#list+1] = id
            p_vars["..."] = id
            scan()
            break
        }
        if p_tok != "id" {
            break
        }
        id := Node.["param", p_tokpos, #p_lit, p_lit]
        list[#list+1] = id
        assertf(p_vars[p_lit] == nil, "parameter '%s' is already declared", p_lit)
        p_vars[p_lit] = id
        scan()
        if p_tok != "," {
            break
        }
        scan()
    }
    skip(")")
    return Node.["params", pos, p_endpos-pos, list]
}

parse_func = func(lambda) {
    pos := p_tokpos
    name := false
    receiver := false
    dot := false
    vars := nil
    skip("func")
    if !lambda {
        expect("id")
        name = p_lit
        scan()
        if p_tok == "." {
            dot = true
            scan()
            expect("id")
            assertf(find_var(name), "undeclared variable '%s'", name)
            receiver = name
            name = p_lit
            scan()
            vars = {"self": Node.["id", 0, 0, "self", false, false]}
        } else if p_tok == "::" {
            scan()
            expect("id")
            assertf(find_var(name), "undeclared variable '%s'", name)
            receiver = name
            name = p_lit
            scan()
        } else {
            assertf(!find_var(name), "re-declaring variable '%s'", name)
        }
        p_vars[name] = {} // hack for recursion
    }
    open_scope(vars)
    params := parse_params()
    body := parse_block()
    close_scope()
    node := Node.["func", pos, p_endpos-pos, name, params, body, receiver, dot]
    if !lambda {
        p_vars[name] = node
    }
    return node
}

func parse_statement() {
    switch p_tok {
    case "id":
        return parse_set_or_call()
    case "func":
        return parse_func()
    case "if":
        return parse_if()
    case "{":
        return parse_block()
    case "for":
        return parse_for()
    case "return":
        return parse_return()
    case "break":
        return parse_break()
    case "continue":
        return parse_continue()
    case "switch":
        return parse_switch()
    case "const":
        return parse_const()
    case ";":
        scan()
        return Node.["nop", p_curpos, 1]
    }
    return nil
}

parse_body = func(vars) {
    open_scope(vars)
    body := List.[]
    for true {
        stmt := parse_statement()
        if stmt == nil {
            break
        }
        body[#body+1] = stmt
    }
    close_scope()
    return body
}

parse_block = func(vars, loop) {
    pos := p_tokpos
    skip("{")
    body := parse_body(vars)
    skip("}")
    if loop && p_continue[p_looplevel] {
        body[#body+1] = Node.["label", 0, 0, "continue"]
        p_continue[p_looplevel] = false
        p_looplevel = p_looplevel - 1
    }
    return Node.["block", pos, p_endpos-pos, body]
}

func parse_module(src, path, vars) {
    p_path = path
    p_src = src
    p_line = 1
    p_curpos = 0
    p_tokpos = 0
    p_endpos = 0
    p_chr = nil
    p_tok = nil
    p_lit = ""
    p_val = nil
    p_comments = List.[]
    p_vars = {_G: ["id", 0, 0, "_G", false, false]}
    p_level = 1
    p_scope = List.[p_vars]
    p_continue = List.[]
    p_looplevel = 0
    p_curpos += 1; p_chr = string_byte(p_src, p_curpos)
    scan()
    pos := p_tokpos
    body := parse_body(vars)
    module := Node.["module", pos, p_endpos-pos, body, p_comments]
    if p_tok != nil {
        errorf("unexpected '%s'", p_tok)
    }
    return module
}

v_res := []
v_level := 0
LUA_OPS := setmetatable({
    "!"  : "not ",
    "&&" : "and",
    "||" : "or",
    "!=" : "~=",
}, {
    __index: func(t, k) {
        return k
    },
})

func space() {
    return string_rep("    ", v_level)
}

func add(s) {
    v_res[#v_res+1] = s
}

visit_expr := nil

func visit_field(node) {
    args := node[4]
    paren := node[7]
    name := node[5]
    if args {
        if node[6] {
            add(":" .. name)
        } else {
            if KEYWORDS[name] || RESERVED[name] {
                add("[\"" .. name .. "\"]")
            } else {
                add("." .. name)
            }
        }
        if paren {
            add("(")
        }
        if #args > 0 {
            for _, v in ipairs(args) {
                visit_expr(v)
                add(", ")
            }
            v_res[#v_res] = ""
        }
        if paren {
            add(")")
        }
    } else {
        if KEYWORDS[name] || RESERVED[name] {
            add("[\"" .. name .. "\"]")
        } else {
            add("." .. name)
        }
    }
}

func visit_index(node) {
    add("[")
    visit_expr(node[4])
    add("]")
}

func visit_value(node) {
    v := node[4]
    if type(v) == "string" {
        tail := node[5]
        if tail {
            add("(\"" .. v .. "\")")
            for _, _v in ipairs(tail) {
                if _v[1] == "field" {
                    visit_field(_v)
                } else {
                    visit_index(_v)
                }
            }
        } else {
            add("\"" .. v .. "\"")
        }
    } else {
        add(tostring(v))
    }
}

func visit_id(node) {
    tail, args, _const, paren := node[5], node[6], node[7], node[8]
    if _const && _const[1] == "value" {
        visit_value(_const)
        return
    }
    add(node[4])
    if args {
        if paren {
            add("(")
        }
        if #args > 0 {
            for _, v in ipairs(args) {
                visit_expr(v)
                add(", ")
            }
            v_res[#v_res] = ""
        }
        if paren {
            add(")")
        }
    }
    if tail {
        for _, v in ipairs(tail) {
            if v[1] == "field" {
                visit_field(v)
            } else {
                visit_index(v)
            }
        }
    }
}

func visit_pair(node) {
    key := node[4]
    if key[1] == "id" && !key[5] && !key[6] {
        name := key[4]
        if KEYWORDS[name] || RESERVED[name] {
            add("[\"")
            visit_expr(key)
            add("\"]")
        } else {
            visit_expr(key)
        }
    } else if key[1] == "index" {
        visit_index(key)
    } else {
        add("[")
        visit_expr(key)
        add("]")
    }
    add(" = ")
    visit_expr(node[5])
}

func visit_table(node) {
    if #node[4] == 0 {
        add("{}")
        return
    }
    add("{\n")
    v_level += 1
    for _, v in ipairs(node[4]) {
        add(space())
        if v[1] == "pair" {
            visit_pair(v)
            add(";\n")
        } else {
            visit_expr(v)
            add(",\n")
        }
    }
    v_level -= 1
    add(space() .. "}")
}

func visit_list(node) {
    add("{")
    list := node[4]
    if #list > 0 {
        for _, v in ipairs(list) {
            visit_expr(v)
            add(", ")
        }
        v_res[#v_res] = ""
    }
    add("}")
}

func visit_paren(node) {
    add("(")
    visit_expr(node[4])
    add(")")
}

func visit_unop(node) {
    op := LUA_OPS[node[4]]
    if op != "+" {
        add(LUA_OPS[node[4]])
    }
    visit_expr(node[5])
}

func visit_binop(node) {
    visit_expr(node[4])
    add(" " .. LUA_OPS[node[5]] .. " ")
    visit_expr(node[6])
}

visit_func := nil

visit_expr = func(node) {
    switch node[1] {
    case "id":
        visit_id(node)
    case "binop":
        visit_binop(node)
    case "unop":
        visit_unop(node)
    case "paren":
        visit_paren(node)
    case "value":
        visit_value(node)
    case "table":
        visit_table(node)
    case "list":
        visit_list(node)
    case "func":
        visit_func(node, true)
    case "vararg":
        add("...")
    default:
        errorf("unknown node type: '%s'", node[1])
    }
}

visit_stmt := nil

func visit_body(node, skip_break) {
    v_level += 1
    for _, v in ipairs(node) {
        visit_stmt(v, skip_break)
    }
    v_level -= 1
}

func visit_block(node, skip_break) {
    visit_body(node[4], skip_break)
}

func visit_call(node) {
    add(space())
    visit_id(node[4])
    add("\n")
}

func visit_set(node) {
    add(space())
    for _, v in ipairs(node[4]) {
        visit_id(v)
        add(", ")
    }
    v_res[#v_res] = " = "
    for _, v in ipairs(node[5]) {
        visit_expr(v)
        add(", ")
    }
    v_res[#v_res] = "\n"
}

func visit_inc(node) {
    add(space())
    visit_id(node[4])
    add(" = ")
    visit_id(node[4])
    add(" + ")
    visit_expr(node[5])
    add("\n")
}

func visit_dec(node) {
    add(space())
    visit_id(node[4])
    add(" = ")
    visit_id(node[4])
    add(" - ")
    visit_expr(node[5])
    add("\n")
}

func visit_let(node) {
    add(space() .. "local ")
    for _, v in ipairs(node[4]) {
        visit_id(v)
        add(", ")
    }
    v_res[#v_res] = " = "
    for _, v in ipairs(node[5]) {
        visit_expr(v)
        add(", ")
    }
    v_res[#v_res] = "\n"
}

func visit_if(node) {
    add(space() .. "if ")
    visit_expr(node[4])
    add(" then\n")
    visit_block(node[5])
    _else := node[6]
    for _else {
        add(space() .. "else")
        if _else[1] == "if" {
            add("if ")
            visit_expr(_else[4])
            add(" then\n")
            visit_block(_else[5])
            _else = _else[6]
        } else {
            add("\n")
            visit_block(_else)
            _else = nil
        }
    }
    add(space() .. "end\n")
}

func visit_switch(node) {
    expr := node[4]
    if expr {
        add(space() .. "do\n")
        v_level += 1
        add(space() .. "local case = ")
        visit_expr(expr)
        add("\n" .. space())
        for _, _case in ipairs(node[5]) {
            add("if ")
            case_exp := _case[5]
            if case_exp {
                add("(")
            }
            for _, item in ipairs(_case[4]) {
                add("case == ")
                if item[1] == "binop" {
                    add("(")
                    visit_expr(item)
                    add(")")
                } else {
                    visit_expr(item)
                }
                add(" or ")
            }
            if case_exp {
                v_res[#v_res] = ") and ("
                visit_expr(case_exp)
                add(")")
            } else {
                v_res[#v_res] = ""
            }
            add(" then\n")
            visit_body(_case[6])
            add(space() .. "else")
        }
        _default := node[6]
        if _default {
            add("\n")
            visit_body(_default)
        } else {
            v_res[#v_res] = ""
        }
        add(space() .. "end\n")
        v_level -= 1
        add(space() .. "end\n")
    } else {
        add(space())
        for _, _case in ipairs(node[5]) {
            add("if ")
            visit_expr(_case[5])
            add(" then\n")
            visit_body(_case[6])
            add(space() .. "else")
        }
        _default := node[6]
        if _default {
            add("\n")
            visit_body(_default)
        } else {
            v_res[#v_res] = ""
        }
        add(space() .. "end\n")
    }
}

func visit_for(node) {
    expr := node[4]
    block := node[5]
    body := block[4]
    if !expr && #body > 0 {
        last := body[#body]
        if last[1] == "break" {
            break_expr := last[4]
            if break_expr {
                add(space() .. "repeat\n")
                visit_block(block, true)
                add(space() .. "until ")
                visit_expr(break_expr)
                add("\n")
                return
            }
        }
    }
    add(space() .. "while ")
    if expr {
        visit_expr(expr)
    } else {
        add("true")
    }
    add(" do\n")
    visit_block(block)
    add(space() .. "end\n")
}

func visit_for_to(node) {
    add(space() .. "for ")
    visit_id(node[4])
    add(" = ")
    visit_expr(node[5])
    add(", ")
    visit_expr(node[6])
    step := node[7]
    if step {
        add(", ")
        visit_expr(step)
    }
    add(" do\n")
    visit_block(node[8])
    add(space() .. "end\n")
}

func visit_for_in(node) {
    add(space() .. "for ")
    for _, v in ipairs(node[4]) {
        visit_id(v)
        add(", ")
    }
    v_res[#v_res] = " in "
    for _, v in ipairs(node[5]) {
        visit_expr(v)
        add(", ")
    }
    v_res[#v_res] = " do\n"
    visit_block(node[6])
    add(space() .. "end\n")
}

func visit_return(node) {
    list := node[4]
    add(space() .. "return")
    if list {
        add(" ")
        for _, v in ipairs(list) {
            visit_expr(v)
            add(", ")
        }
        v_res[#v_res] = ""
    }
    add("\n")
}

func visit_break(node) {
    expr := node[4]
    if expr {
        add(space() .. "if ")
        visit_expr(expr)
        add(" then\n")
        v_level = v_level + 1
        add(space() .. "break\n")
        v_level = v_level - 1
        add(space() .. "end\n")
    } else {
        add(space() .. "break\n")
    }
}

func visit_continue(node) {
    add(space() .. "goto continue\n")
}

func visit_label(node) {
    add(space() .. "::" .. node[4] .. "::\n")
}

func visit_params(node) {
    t := {}
    for _, v in ipairs(node[4]) {
        t[#t+1] = v[4]
    }
    add("("..table_concat(t, ", ")..")\n")
}

visit_func = func(node, lambda) {
    if lambda {
        add("function")
    } else if node[7] {
        if node[8] {
            add(space() .. "function " .. node[7] .. ":" .. node[4])
        } else {
            add(space() .. "function " .. node[7] .. "." .. node[4])
        }
    } else {
        add(space() .. "local function " .. node[4])
    }
    visit_params(node[5])
    visit_block(node[6])
    add(space() .. "end")
    if !lambda {
        add("\n")
    }
}

func visit_nop(node) {
    v_res[#v_res] = ";\n"
}

visit_stmt = func(node, skip_break) {
    switch node[1] {
    case "call":
        visit_call(node)
    case "set":
        visit_set(node)
    case "inc":
        visit_inc(node)
    case "dec":
        visit_dec(node)
    case "let":
        visit_let(node)
    case "if":
        visit_if(node)
    case "switch":
        visit_switch(node)
    case "block":
        add(space() .. "do\n")
        visit_block(node)
        add(space() .. "end\n")
    case "for":
        visit_for(node)
    case "for_to":
        visit_for_to(node)
    case "for_in":
        visit_for_in(node)
    case "return":
        visit_return(node)
    case "break":
        if !skip_break {
            visit_break(node)
        }
    case "continue":
        visit_continue(node)
    case "label":
        visit_label(node)
    case "func":
        visit_func(node)
    case "nop":
        visit_nop(node)
    case "const":
        // skip
    default:
        errorf("unknown node type: %s", node[1])
    }
}

func visit_module(node, level) {
    v_res = []
    v_level = level || 0
    for _, v in ipairs(node[4]) {
        visit_stmt(v)
    }
    return table_concat(v_res)
}

{
    fn := _G.arg[1]
    if fn {
        os, io, pcall, print := _G.os, _G.io, _G.pcall, _G.print
        src := io::open(fn, "r").read("a")
        r, m := pcall(parse_module, src, fn)
        if r {
            res := visit_module(m, 0)
            out := _G.arg[2]
            if out {
                io::open(out, "w").write(res)
            } else {
                io::open(fn .. ".lua", "w").write(res)
            }
            print(os::clock())
        } else {
            print(m)
            os::exit(1)
        }
    }
}

return {
    Node: Node,
    nodes: nodes,
    parse_module: parse_module,
    visit_module: visit_module,
}
