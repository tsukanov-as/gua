-- MIT License

-- Copyright (c) 2021 tsukanov-as

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

_G::setfenv(1, {_G: _G})

string_byte := _G.string.byte
string_sub := _G.string.sub
string_rep := _G.string.rep
string_format := _G.string.format
string_find := _G.string.find
table_concat := _G.table.concat
table_sort := _G.table.sort
tonumber := _G.tonumber
assert := _G.assert
setmetatable := _G.setmetatable
pairs := _G.pairs
ipairs := _G.ipairs
tostring := _G.tostring
error := _G.error
type := _G.type

Type := {
    __call: func(self, t) {
        if self.init {
            t = self.init(t)
        }
        return setmetatable(t, self)
    },
}
setmetatable(Type, Type)

Hex := Type.{
    __tostring: func(t) {
        return string_format("0x%02X", t[1])
    },
}

Raw := Type.{
    __tostring: func(t) {
        s := t[1]
        i := 0
        x := nil
        for true {
            x = string_rep("=", i)
            if !string_find(s, "[" .. x .. "[", 1, true)
                && !string_find(s, "]" .. x .. "]", 1, true) {
                break
            }
            i = i + 1
        }
        return string_format(" [%s[%s]%s]", x, s, x)
    },
}

List := Type.{
    __tostring: func(t) {
        res := {}
        for i, v in ipairs(t) {
            if type(v) == "string" {
                res[i] = string_format("%q", v)
            } else {
                res[i] = tostring(v)
            }
        }
        return "{" .. table_concat(res, ", ") .. "}"
    },
}

Set := Type.{
    __tostring: func(t) {
        res := {}
        for k in pairs(t) {
            if type(k) == "string" {
                res[#res+1] = string_format("%q", k)
            } else {
                res[#res+1] = tostring(k)
            }
        }
        table_sort(res)
        return "{" .. table_concat(res, ", ") .. "}"
    },
    init: func(self, t) {
        set := {}
        for _, v in ipairs(t) {
            set[v] = v
        }
        return set
    },
}

Fields := Type.{
    __tostring: func(t) {
        res := {}
        for i, v in ipairs(t) {
            res[#res+1] = string_format("%d:%q", i, v)
        }
        table_sort(res)
        return "{" .. table_concat(res, ", ") .. "}"
    },
    init: func(self, t) {
        fields := {}
        for i, v in ipairs(t) {
            fields[i] = v
            fields[v] = i
        }
        return fields
    },
}

nodes := {
    "module"   : Fields.["Type", "Pos", "Len", "Body", "Comments"],
    "value"    : Fields.["Type", "Pos", "Len", "Value"],
    "field"    : Fields.["Type", "Pos", "Len", "Args", "Name", "Dot", "Paren"],
    "index"    : Fields.["Type", "Pos", "Len", "Expr"],
    "id"       : Fields.["Type", "Pos", "Len", "Name", "Tail", "Args", "Const", "Paren"],
    "table"    : Fields.["Type", "Pos", "Len", "List"],
    "pair"     : Fields.["Type", "Pos", "Len", "Left", "Right"],
    "list"     : Fields.["Type", "Pos", "Len", "List"],
    "paren"    : Fields.["Type", "Pos", "Len", "Expr"],
    "unop"     : Fields.["Type", "Pos", "Len", "Op", "Expr"],
    "binop"    : Fields.["Type", "Pos", "Len", "Left", "Op", "Right"],
    "call"     : Fields.["Type", "Pos", "Len", "ID"],
    "set"      : Fields.["Type", "Pos", "Len", "Left", "Right"],
    "let"      : Fields.["Type", "Pos", "Len", "Left", "Right"],
    "inc"      : Fields.["Type", "Pos", "Len", "ID", "Expr"],
    "dec"      : Fields.["Type", "Pos", "Len", "ID", "Expr"],
    "if"       : Fields.["Type", "Pos", "Len", "Expr", "Then", "Else"],
    "block"    : Fields.["Type", "Pos", "Len", "Body"],
    "for"      : Fields.["Type", "Pos", "Len", "Expr", "Body"],
    "for_to"   : Fields.["Type", "Pos", "Len", "ID", "From", "Limit", "Step", "Body"],
    "for_in"   : Fields.["Type", "Pos", "Len", "IDs", "INs", "Body"],
    "return"   : Fields.["Type", "Pos", "Len", "List"],
    "break"    : Fields.["Type", "Pos", "Len", "Expr"],
    "continue" : Fields.["Type", "Pos", "Len"],
    "label"    : Fields.["Type", "Pos", "Len", "Name"],
    "func"     : Fields.["Type", "Pos", "Len", "Name", "Params", "Body", "Receiver", "Dot"],
    "nop"      : Fields.["Type", "Pos", "Len"],
    "vararg"   : Fields.["Type", "Pos", "Len"],
    "param"    : Fields.["Type", "Pos", "Len", "Name"],
    "params"   : Fields.["Type", "Pos", "Len", "List"],
    "switch"   : Fields.["Type", "Pos", "Len", "Expr", "Cases", "Default"],
    "case"     : Fields.["Type", "Pos", "Len", "List", "Expr", "Body"],
    "const"    : Fields.["Type", "Pos", "Len", "List"],
}

Node := Type.{
    __tostring: List.__tostring,
    __index: func(t, k) {
        if type(k) == "string" {
            _type := t[1]
            if k == "Type" {
                return _type
            }
            return t[nodes[_type][k]]
        }
        return nil
    },
}

KEYWORDS := Set.["break", "continue", "else", "false", "for", "func", "if", "in", "nil", "return", "true", "switch", "case", "default", "const"]
RESERVED := Set.["local", "function", "while", "do", "end", "repeat", "until", "and", "or", "not", "then", "elseif"]
LITERALS := Set.["str", "chr", "raw", "num", "true", "false", "nil"]
REL_OPS := Set.["==", "!=", "<", ">", "<=", ">="]
MUL_OPS := Set.["*", "/", "%"]
ADD_OPS := Set.["+", "-"]
UNR_OPS := Set.["+", "-", "!", "#"]

LF := 0x0A
ALPHA := 1
DIGIT := 2
SPACE := 3

MAP := {
    [string_byte"\""]: "str",
    [string_byte"'"]: "chr",
    [string_byte"`"]: "raw",
}
HEX := {}
{
    sym := "()[]{}*:;.,/+-=<>#%|&!^"
    for i := 1, #sym {
        MAP[string_byte(sym, i)] = string_sub(sym, i, i)
    }
    for i := 0x01, 0x20 {
        MAP[i] = SPACE
    }
    for i := '0', '9' {
        MAP[i] = DIGIT
    }
    abc := "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    for i := 1, #abc {
        MAP[string_byte(abc, i)] = ALPHA
    }
    hex := "ABCDEFabcdef0123456789"
    for i := 1, #hex {
        HEX[string_byte(hex, i)] = true
    }
}

-------------------------------------------------------------------------------
-- parser state
p_path := nil
p_src := nil
p_line := 1
p_curpos := 0
p_tokpos := 0 -- current token pos
p_endpos := 0 -- previous token end pos
p_chr := nil
p_tok := nil
p_lit := ""
p_val := nil
p_comments := List.[]
p_vars := {}
p_scope := {}
p_level := 0
p_skip_id_check := false
p_skipped_id_name := nil
p_continue := List.[]
p_looplevel := 0
-------------------------------------------------------------------------------

func errorf(notef, ...) {
    if p_path {
        error(p_path .. ":" .. p_line .. ": " .. string_format(notef, ...), 2)
    } else {
        error(string_format(notef, ...) .. " in line " .. p_line, 2)
    }
}

func next() {
    p_curpos = p_curpos + 1
    p_chr = string_byte(p_src, p_curpos)
    return p_chr
}

func scan() {
    for {
        p_tok = MAP[p_chr]
        p_lit = ""
        p_val = nil
        p_endpos = p_curpos
        for p_tok == SPACE {
            if p_chr == LF {
                p_line = p_line + 1
            }
            p_tok = MAP[next()]
        }
        p_tokpos = p_curpos
        if p_tok == ALPHA {
            beg := p_curpos
            for {
                p_tok = MAP[next()]
                break if p_tok != ALPHA && p_tok != DIGIT
            }
            p_lit = string_sub(p_src, beg, p_curpos-1)
            p_tok = KEYWORDS[p_lit] || "id"
            if p_tok == "true" {
                p_val = true
            } else if p_tok == "false" {
                p_val = false
            }
        } else if p_tok == DIGIT {
            beg := p_curpos
            base := 10
            if p_chr == 0x30 { -- 0
                next()
                if p_chr == 0x58 || p_chr == 0x78 { -- X, x
                    next()
                    beg = p_curpos
                    if HEX[p_chr] == nil {
                        errorf("expected hex digit, found '%c'", p_chr)
                    }
                    for {
                        next()
                        break if !HEX[p_chr]
                    }
                    base = 16
                    if p_curpos-beg > 8 {
                        errorf("integer greater than 32 bits", p_tok)
                    }
                } else if p_chr == 0x42 || p_chr == 0x62 { -- B, b
                    next()
                    beg = p_curpos
                    if p_chr != 0x30 && p_chr != 0x31 {
                        errorf("expected bin digit, found '%c'", p_chr)
                    }
                    for {
                        next()
                        break if p_chr != 0x30 && p_chr != 0x31
                    }
                    base = 2
                    if p_curpos-beg > 32 {
                        errorf("integer greater than 32 bits", p_tok)
                    }
                }
            }
            if base == 10 {
                p_tok = MAP[p_chr]
                for p_tok == DIGIT {
                    p_tok = MAP[next()]
                }
                if p_chr == 0x2E { -- .
                    for {
                        p_tok = MAP[next()]
                        break if p_tok != DIGIT
                    }
                }
                if p_chr == 0x45 || p_chr == 0x65 { -- E, e
                    next()
                    if p_chr == 0x2B || p_chr == 0x2D { -- +, -
                        next()
                    }
                    p_tok = MAP[p_chr]
                    if p_tok != DIGIT {
                        errorf("expected digit, found '%s'", p_tok)
                    }
                    for {
                        p_tok = MAP[next()]
                        break if p_tok != DIGIT
                    }
                }
            }
            p_tok = "num"
            p_lit = string_sub(p_src, beg, p_curpos-1)
            if base == 10 {
                p_val = tonumber(p_lit)
            } else {
                p_val = Hex.[tonumber(p_lit, base)]
            }
            if p_val == nil {
                errorf("malformed number '%s'", p_lit)
            }
        } else if p_tok == "str" {
            beg := p_curpos
            for {
                if next() == 0x5C { -- \
                    next()
                    next()
                }
                break if p_chr == 0x22 || p_chr == LF || p_chr == nil
            }
            if p_chr != 0x22 {
                errorf("expected \", found EOL")
            }
            p_lit = string_sub(p_src, beg+1, p_curpos-1)
            p_val = p_lit
            next()
        } else if p_tok == "raw" {
            beg := p_curpos
            for {
                next()
                if p_chr == LF {
                    p_line = p_line + 1
                }
                break if p_chr == 0x60 || p_chr == nil
            }
            if p_chr != 0x60 {
                errorf("expected `, found '%c'", p_chr)
            }
            p_lit = string_sub(p_src, beg+1, p_curpos-1)
            p_val = Raw.[p_lit]
            next()
        } else if p_tok == "chr" {
            beg := p_curpos
            next()
            next()
            if p_chr != 0x27 {
                errorf("expected ', found '%c'", p_chr)
            }
            p_lit = string_sub(p_src, beg+1, p_curpos-1)
            p_val = Hex.[string_byte(p_lit)]
            next()
        } else if p_tok == ":" {
            next()
            if p_chr == 0x3D {
                p_tok = ":="
                next()
            } else if p_chr == 0x3A {
                p_tok = "::"
                next()
            }
        } else if p_tok == "=" {
            next()
            if p_chr == 0x3D {
                p_tok = "=="
                next()
            }
        } else if p_tok == "+" {
            next()
            if p_chr == 0x3D {
                p_tok = "+="
                next()
            }
        } else if p_tok == "-" {
            next()
            if p_chr == 0x2D {
                beg := p_curpos
                for {
                    next()
                    break if p_chr == LF || p_chr == nil
                }
                p_lit = string_sub(p_src, beg+1, p_curpos-1)
                p_comments[p_line] = p_lit
                p_tok = "--"
            } else if p_chr == 0x3D {
                p_tok = "-="
                next()
            }
        } else if p_tok == "<" {
            next()
            if p_chr == 0x3D {
                p_tok = "<="
                next()
            }
        } else if p_tok == ">" {
            next()
            if p_chr == 0x3D {
                p_tok = ">="
                next()
            }
        } else if p_tok == "&" {
            next()
            if p_chr == 0x26 {
                p_tok = "&&"
                next()
            }
        } else if p_tok == "|" {
            next()
            if p_chr == 0x7C {
                p_tok = "||"
                next()
            }
        } else if p_tok == "!" {
            next()
            if p_chr == 0x3D {
                p_tok = "!="
                next()
            }
        } else if p_tok == "." {
            next()
            if p_chr == 0x2E {
                p_tok = ".."
                next()
                if p_chr == 0x2E {
                    p_tok = "..."
                    next()
                }
            } else if p_chr == 0x5B {
                p_tok = ".["
                next()
            } else if p_chr == 0x7B {
                p_tok = ".{"
                next()
            }
        } else if p_tok == nil && p_chr != nil {
            errorf("unknown symbol '%c'", p_chr)
        } else {
            next()
        }
        break if p_tok != "--"
    }
    return p_tok
}

func expect(t, l) {
    if p_tok != t {
        str := nil
        if p_tok == "num" || p_tok == "str" || p_tok == "chr" || p_tok == "id" {
            str = p_lit
        } else {
            str = tostring(p_tok)
        }
        if p_path {
            error(string_format("%s:%d: expected '%s', found '%s'", p_path, p_line, tostring(t), str), l || 2)
        } else {
            error(string_format("expected '%s', found '%s' in line %d", tostring(t), str, p_line), l || 2)
        }
    }
}

func skip(t) {
    expect(t, 3)
    return scan()
}

func open_scope(vars) {
    p_vars = vars || {}
    p_level = p_level + 1
    p_scope[p_level] = p_vars
}

func close_scope() {
    p_level = p_level - 1
    p_vars = p_scope[p_level]
}

func find_var(name) {
    if name == "_" {
        return nil
    }
    var := p_vars[name]
    i := p_level
    for var == nil && i > 1 {
        i = i - 1
        var = p_scope[i][name]
    }
    return var, i
}

func assertf(expr, notef, ...) {
    if !expr {
        if p_path {
            error(p_path .. ":" .. p_line .. ": " .. string_format(notef, ...), 2)
        } else {
            error(string_format(notef, ...) .. " in line " .. p_line, 2)
        }
    }
    return expr
}

parse_expr := nil
parse_table, parse_list := nil, nil

func parse_tail(call) {
    tail, i := List.[], 0
    for true {
        pos := p_tokpos
        dot := (p_tok == ".")
        if dot || p_tok == "::" {
            scan()
            if KEYWORDS[p_lit] == nil {
                expect("id")
            }
            name := p_lit
            args := false
            paren := false
            last := p_tokpos
            scan()
            if p_tok == "(" {
                scan()
                args = List.[]
                for p_tok != ")" {
                    args[#args+1] = parse_expr()
                    if p_tok != "," {
                        break
                    }
                    scan()
                }
                last = p_tokpos
                skip(")")
                call = true
                paren = true
            } else if p_tok == "str" {
                args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
                last = p_tokpos
                scan()
                call = true
            } else if p_tok == "chr" {
                args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
                last = p_tokpos
                scan()
                call = true
                paren = true
            } else if p_tok == ".{" {
                args = List.[parse_table()]
                last = p_tokpos
                scan()
                call = true
            } else if p_tok == ".[" {
                args = List.[parse_list()]
                last = p_tokpos
                scan()
                call = true
            } else {
                call = false
            }
            if args && dot && (KEYWORDS[name] || RESERVED[name]) {
                errorf("name '%s' cannot be used in a method call", name)
            }
            item := Node.["field", pos, last - pos, args || false, name, dot, paren]
            i = i + 1
            tail[i] = item
        } else if p_tok == "[" {
            scan()
            assertf(p_tok != "]", "expected expression, found ']'")
            expr := parse_expr()
            skip("]")
            i = i + 1
            tail[i] = Node.["index", pos, p_endpos-pos, expr]
        } else {
            break
        }
    }
    return i > 0 && tail, call
}

func parse_id() {
    pos := p_tokpos
    name := p_lit
    _const := false
    assertf(!RESERVED[name], "name '%s' is reserved", name)
    if p_skip_id_check {
        p_skipped_id_name = name
        p_skip_id_check = false
    } else {
        id := assertf(find_var(name), "undeclared variable '%s'", name)
        _const = id[7]
    }
    call := false
    paren := false
    args, tail := false, false
    scan()
    if !_const {
        if p_tok == "(" {
            scan()
            args = List.[]
            for p_tok != ")" {
                args[#args+1] = parse_expr()
                if p_tok != "," {
                    break
                }
                scan()
            }
            skip(")")
            call = true
            paren = true
        } else if p_tok == "str" {
            args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
            scan()
            call = true
        } else if p_tok == "chr" {
            args = List.[Node.["value", p_tokpos, p_endpos-pos, p_val]]
            scan()
            call = true
            paren = true
        } else if p_tok == ".{" {
            args = List.[parse_table()]
            call = true
        } else if p_tok == ".[" {
            args = List.[parse_list()]
            call = true
        }
        tail, call = parse_tail(call)
    }
    node := Node.["id", pos, p_endpos-pos, name, tail, args, _const, paren]
    return node, call
}

func parse_paren() {
    pos := p_tokpos
    skip("(")
    expr := parse_expr()
    skip(")")
    return Node.["paren", pos, p_endpos-pos, expr]
}

parse_table = func() {
    pos := p_tokpos
    list := List.[]
    scan() -- skip "{" || ".{"
    for p_tok != "}" {
        key_pos := p_tokpos
        left := nil
        if p_tok == "id" || KEYWORDS[p_lit] {
            left = Node.["id", key_pos, #p_lit, p_lit, false, false]
            scan()
        } else if p_tok == "[" {
            scan()
            expr := parse_expr()
            skip("]")
            left = Node.["index", key_pos, p_endpos-key_pos, expr]
        } else {
            left = parse_expr()
        }
        expect(":")
        scan()
        right := parse_expr()
        list[#list+1] = Node.["pair", pos, p_endpos-pos, left, right]
        if p_tok != "," {
            break
        }
        scan()
    }
    skip("}")
    return Node.["table", pos, p_endpos-pos, list]
}

parse_list = func() {
    pos := p_tokpos
    list := List.[]
    scan() -- skip "[" || ".["
    for p_tok != "]" {
        list[#list+1] = parse_expr()
        if p_tok != "," {
            break
        }
        scan()
    }
    skip("]")
    return Node.["list", pos, p_endpos-pos, list]
}

parse_func := nil

func parse_operand() {
    node := nil
    if p_tok == "str" {
        pos, len, val := p_tokpos, #p_lit, p_val
        scan()
        tail := parse_tail()
        node = Node.["value", pos, len, val, tail]
    } else if LITERALS[p_tok] {
        node = Node.["value", p_tokpos, #p_lit, p_val]
        scan()
    } else if p_tok == "id" {
        node = parse_id()
    } else if p_tok == "(" {
        node = parse_paren()
    } else if p_tok == "{" {
        node = parse_table()
    } else if p_tok == "[" {
        node = parse_list()
    } else if p_tok == "func" {
        node = parse_func(true)
    } else if p_tok == "..." {
        node = Node.["vararg", p_tokpos, 3]
        scan()
    } else {
        errorf("expected operand, found '%s'", p_tok)
    }
    return node
}

func parse_pow() {
    pos := p_tokpos
    left := parse_operand()
    for p_tok == "^" {
        scan()
        right := parse_operand()
        left = Node.["binop", pos, p_endpos-pos, left, "^", right]
    }
    return left
}

func parse_unary() {
    pos := p_tokpos
    expr := nil
    if UNR_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_pow()
        expr = Node.["unop", pos, p_endpos-pos, op, right]
    } else {
        expr = parse_pow()
    }
    return expr
}

func parse_mul() {
    pos := p_tokpos
    left := parse_unary()
    for MUL_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_unary()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

func parse_add() {
    pos := p_tokpos
    left := parse_mul()
    for ADD_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_mul()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

func parse_cat() {
    pos := p_tokpos
    left := parse_add()
    for p_tok == ".." {
        scan()
        right := parse_add()
        left = Node.["binop", pos, p_endpos-pos, left, "..", right]
    }
    return left
}

func parse_rel() {
    pos := p_tokpos
    left := parse_cat()
    for REL_OPS[p_tok] {
        op := p_tok
        scan()
        right := parse_cat()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

func parse_and() {
    pos := p_tokpos
    left := parse_rel()
    for p_tok == "&&" {
        op := p_tok
        scan()
        right := parse_rel()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

parse_expr = func() {
    pos := p_tokpos
    left := parse_and()
    for p_tok == "||" {
        op := p_tok
        scan()
        right := parse_and()
        left = Node.["binop", pos, p_endpos-pos, left, op, right]
    }
    return left
}

parse_block, parse_body := nil, nil

func parse_set_or_call() {
    pos := p_tokpos
    name := p_lit
    p_skip_id_check = true
    id, call := parse_id()
    if call {
        assertf(find_var(name), "undeclared variable '%s'", name)
        return Node.["call", pos, p_endpos-pos, id]
    }
    if p_tok == "+=" {
        assertf(find_var(name), "undeclared variable '%s'", name)
        scan()
        expr := parse_add()
        return Node.["inc", pos, p_endpos-pos, id, expr]
    }
    if p_tok == "-=" {
        assertf(find_var(name), "undeclared variable '%s'", name)
        scan()
        expr := parse_add()
        return Node.["dec", pos, p_endpos-pos, id, expr]
    }
    left := List.[id]
    for p_tok == "," {
        scan()
        expect("id")
        p_skip_id_check = true
        id, call = parse_id()
        assertf(!call, "unexpected call")
        left[#left+1] = id
    }
    if p_tok == "=" {
        for _, _id in ipairs(left) {
            name = _id[4]
            v := assertf(find_var(name), "undeclared variable '%s'", name)
            assertf(!v[7], "cannot assign to '%s' (declared const)", name)
        }
        scan()
        right := List.[]
        for true {
            right[#right+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
        return Node.["set", pos, p_endpos-pos, left, right]
    }
    if p_tok == ":=" {
        allow := false
        for _, _id in ipairs(left) {
            assertf(!_id[5], "unexpected tail")
            assertf(!_id[6], "unexpected call")
            assertf(!_id[7], "unexpected self")
            var, level := find_var(_id[4])
            if !var {
                allow = true
            } else if level != p_level || var[7] {
                errorf("variable shadowing is prohibited, you need to change the name '%s'", p_skipped_id_name)
            }
        }
        assertf(allow, "no new variables on left side of ':='")
        scan()
        right := List.[]
        for true {
            right[#right+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
        for _, v in ipairs(left) {
            p_vars[v[4]] = v
        }
        return Node.["let", pos, p_endpos-pos, left, right]
    }
    expect("=")
}

func parse_if() {
    pos := p_tokpos
    skip("if")
    expr := parse_expr()
    body := parse_block()
    else_body := false
    if p_tok == "else" {
        scan()
        if p_tok == "if" {
            else_body = parse_if()
        } else {
            else_body = parse_block()
        }
    }
    return Node.["if", pos, p_endpos-pos, expr, body, else_body]
}

func parse_switch() {
    pos := p_tokpos
    skip("switch")
    expr := false
    cases := List.[]
    if p_tok == "{" {
        scan()
        for p_tok == "case" {
            scan()
            case_expr := parse_expr()
            skip(":")
            body := parse_body()
            cases[#cases+1] = Node.["case", pos, p_endpos-pos, false, case_expr, body]
        }
    } else {
        expr = parse_expr()
        skip("{")
        expect("case")
        for p_tok == "case" {
            scan()
            list := List.[]
            for true {
                list[#list+1] = parse_expr()
                if p_tok != "," {
                    break
                }
                scan()
            }
            case_expr := false
            if p_tok == ";" {
                scan()
                case_expr = parse_expr()
            }
            skip(":")
            body := parse_body()
            cases[#cases+1] = Node.["case", pos, p_endpos-pos, list, case_expr, body]
        }
    }
    _default := false
    if p_tok == "default" {
        scan()
        skip(":")
        _default = parse_body()
    }
    skip("}")
    return Node.["switch", pos, p_endpos-pos, expr, cases, _default]
}

func parse_for() {
    pos := p_tokpos
    p_looplevel = p_looplevel + 1
    skip("for")
    if p_tok == "{" {
        body := parse_block(nil, true)
        return Node.["for", pos, p_endpos-pos, false, body]
    }
    p_skip_id_check = true
    expr := parse_expr()
    if p_tok == "{" || expr[1] != "id" || expr[5] || expr[6] {
        assertf(find_var(p_skipped_id_name), "undeclared variable '%s'", p_skipped_id_name)
        body := parse_block(nil, true)
        return Node.["for", pos, p_endpos-pos, expr, body]
    }
    vars := {[expr[4]]: expr}
    if p_tok == ":=" {
        assertf(!find_var(p_skipped_id_name), "variable shadowing is prohibited, you need to change the name '%s'", p_skipped_id_name)
        scan()
        from := parse_expr()
        skip(",")
        to := parse_expr()
        by := nil
        if p_tok == "," {
            scan()
            by = parse_expr()
        }
        body := parse_block(vars, true)
        return Node.["for_to", pos, p_endpos-pos, expr, from, to, by || false, body]
    }
    assertf(!find_var(p_skipped_id_name), "variable shadowing is prohibited, you need to change the name '%s'", p_skipped_id_name)
    ids := List.[expr]
    for p_tok == "," {
        scan()
        expect("id")
        name := p_lit
        assertf(!RESERVED[name], "name '%s' is reserved", name)
        assertf(!find_var(name), "variable shadowing is prohibited, you need to change the name '%s'", name)
        id := Node.["id", p_tokpos, #name, name, false, false]
        ids[#ids+1] = id
        assertf(vars[name] == nil, "re-declaring variable '%s'", name)
        vars[name] = id
        scan()
    }
    expect("in")
    ins := List.[]
    scan()
    ins[#ins+1] = parse_expr()
    if p_tok == "," {
        scan()
        ins[#ins+1] = parse_expr()
    }
    if p_tok == "," {
        scan()
        ins[#ins+1] = parse_expr()
    }
    body := parse_block(vars, true)
    return Node.["for_in", pos, p_endpos-pos, ids, ins, body]
}

func parse_return() {
    pos := p_tokpos
    skip("return")
    list := List.[]
    if p_tok != "}" {
        for true {
            list[#list+1] = parse_expr()
            if p_tok != "," {
                break
            }
            scan()
        }
    }
    if p_tok {
        expect("}")
    }
    return Node.["return", pos, p_endpos-pos, list]
}

func parse_break() {
    pos := p_tokpos
    assert(p_looplevel > 0, "no loop to break")
    skip("break")
    expr := false
    if p_tok == "if" {
        scan()
        expr = parse_expr()
    }
    expect("}")
    return Node.["break", pos, 5, expr]
}

func parse_continue() {
    pos := p_tokpos
    assert(p_looplevel > 0, "no loop to continue")
    skip("continue")
    expect("}")
    p_continue[p_looplevel] = true
    return Node.["continue", pos, 8]
}

func parse_const() {
    pos := p_tokpos
    skip("const")
    if p_tok == "id" {
        name := p_lit
        assertf(!RESERVED[name], "name '%s' is reserved", name)
        assertf(!find_var(name), "variable shadowing is prohibited, you need to change the name '%s'", name)
        id := Node.["id", p_tokpos, #name, name, false, false, nil]
        list := List.[id]
        scan()
        skip("=")
        assertf(LITERALS[p_tok], "expected value")
        id[7] = Node.["value", p_tokpos, #p_lit, p_val]
        p_vars[name] = id
        scan()
        return Node.["const", pos, p_endpos-pos, list]
    }
    if p_tok == "(" {
        scan()
        list := List.[]
        for p_tok == "id" {
            name := p_lit
            assertf(!RESERVED[name], "name '%s' is reserved", name)
            assertf(!find_var(name), "variable shadowing is prohibited, you need to change the name '%s'", name)
            id := Node.["id", p_tokpos, #name, name, false, false, nil]
            list[#list+1] = id
            scan()
            skip("=")
            assertf(LITERALS[p_tok], "expected value")
            id[7] = Node.["value", p_tokpos, #p_lit, p_val]
            p_vars[name] = id
            scan()
        }
        skip(")")
        return Node.["const", pos, p_endpos-pos, list]
    }
    expect("id")
}

func parse_params() {
    pos := p_tokpos
    skip("(")
    list := List.[]
    for true {
        if p_tok == "..." {
            id := Node.["param", p_tokpos, 3, "..."]
            list[#list+1] = id
            p_vars["..."] = id
            scan()
            break
        }
        if p_tok != "id" {
            break
        }
        id := Node.["param", p_tokpos, #p_lit, p_lit]
        list[#list+1] = id
        assertf(p_vars[p_lit] == nil, "parameter '%s' is already declared", p_lit)
        p_vars[p_lit] = id
        scan()
        if p_tok != "," {
            break
        }
        scan()
    }
    skip(")")
    return Node.["params", pos, p_endpos-pos, list]
}

parse_func = func(lambda) {
    pos := p_tokpos
    name := false
    receiver := false
    dot := false
    vars := nil
    skip("func")
    if !lambda {
        expect("id")
        name = p_lit
        scan()
        if p_tok == "." {
            dot = true
            scan()
            expect("id")
            assertf(find_var(name), "undeclared variable '%s'", name)
            receiver = name
            name = p_lit
            scan()
            vars = {"self": Node.["id", 0, 0, "self", false, false]}
        } else if p_tok == "::" {
            scan()
            expect("id")
            assertf(find_var(name), "undeclared variable '%s'", name)
            receiver = name
            name = p_lit
            scan()
        } else {
            assertf(!find_var(name), "re-declaring variable '%s'", name)
        }
        p_vars[name] = {} -- hack for recursion
    }
    open_scope(vars)
    params := parse_params()
    body := parse_block()
    close_scope()
    node := Node.["func", pos, p_endpos-pos, name, params, body, receiver, dot]
    if !lambda {
        p_vars[name] = node
    }
    return node
}

func parse_statement() {
    if p_tok == "id" {
        return parse_set_or_call()
    } else if p_tok == "func" {
        return parse_func()
    } else if p_tok == "if" {
        return parse_if()
    } else if p_tok == "{" {
        return parse_block()
    } else if p_tok == "for" {
        return parse_for()
    } else if p_tok == "return" {
        return parse_return()
    } else if p_tok == "break" {
        return parse_break()
    } else if p_tok == "continue" {
        return parse_continue()
    } else if p_tok == "switch" {
        return parse_switch()
    } else if p_tok == "const" {
        return parse_const()
    } else if p_tok == ";" {
        scan()
        return Node.["nop", p_curpos, 1]
    }
    return nil
}

parse_body = func(vars) {
    open_scope(vars)
    body := List.[]
    for true {
        stmt := parse_statement()
        if stmt == nil {
            break
        }
        body[#body+1] = stmt
    }
    close_scope()
    return body
}

parse_block = func(vars, loop) {
    pos := p_tokpos
    skip("{")
    body := parse_body(vars)
    skip("}")
    if loop && p_continue[p_looplevel] {
        body[#body+1] = Node.["label", 0, 0, "continue"]
        p_continue[p_looplevel] = false
        p_looplevel = p_looplevel - 1
    }
    return Node.["block", pos, p_endpos-pos, body]
}

func parse_module(src, path, vars) {
    p_path = path
    p_src = src
    p_line = 1
    p_curpos = 0
    p_tokpos = 0
    p_endpos = 0
    p_chr = nil
    p_tok = nil
    p_lit = ""
    p_val = nil
    p_comments = List.[]
    p_vars = {_G: ["id", 0, 0, "_G", false, false]}
    p_level = 1
    p_scope = List.[p_vars]
    p_continue = List.[]
    p_looplevel = 0
    next()
    scan()
    pos := p_tokpos
    body := parse_body(vars)
    module := Node.["module", pos, p_endpos-pos, body, p_comments]
    if p_tok != nil {
        errorf("unexpected '%s'", p_tok)
    }
    return module
}

v_res := {}
v_level := 0
LUA_OPS := setmetatable({
    "!"  : "not ",
    "&&" : "and",
    "||" : "or",
    "!=" : "~=",
}, {
    __index: func(t, k) {
        return k
    },
})

func space() {
    return string_rep("    ", v_level)
}

visit_expr := nil

func visit_field(node) {
    args := node[4]
    paren := node[7]
    name := node[5]
    if args {
        if node[6] {
            v_res[#v_res+1] = ":" .. name
        } else {
            if KEYWORDS[name] || RESERVED[name] {
                v_res[#v_res+1] = "[\"" .. name .. "\"]"
            } else {
                v_res[#v_res+1] = "." .. name
            }
        }
        if paren {
            v_res[#v_res+1] = "("
        }
        if #args > 0 {
            for _, v in ipairs(args) {
                visit_expr(v)
                v_res[#v_res+1] = ", "
            }
            v_res[#v_res] = ""
        }
        if paren {
            v_res[#v_res+1] = ")"
        }
    } else {
        if KEYWORDS[name] || RESERVED[name] {
            v_res[#v_res+1] = "[\"" .. name .. "\"]"
        } else {
            v_res[#v_res+1] = "." .. name
        }
    }
}

func visit_index(node) {
    v_res[#v_res+1] = "["
    visit_expr(node[4])
    v_res[#v_res+1] = "]"
}

func visit_value(node) {
    v := node[4]
    if type(v) == "string" {
        tail := node[5]
        if tail {
            v_res[#v_res+1] = "(\"" .. v .. "\")"
            for _, _v in ipairs(tail) {
                if _v[1] == "field" {
                    visit_field(_v)
                } else {
                    visit_index(_v)
                }
            }
        } else {
            v_res[#v_res+1] = "\"" .. v .. "\""
        }
    } else {
        v_res[#v_res+1] = tostring(v)
    }
}

func visit_id(node) {
    tail, args, _const, paren := node[5], node[6], node[7], node[8]
    if _const && _const[1] == "value" {
        visit_value(_const)
        return
    }
    v_res[#v_res+1] = node[4]
    if args {
        if paren {
            v_res[#v_res+1] = "("
        }
        if #args > 0 {
            for _, v in ipairs(args) {
                visit_expr(v)
                v_res[#v_res+1] = ", "
            }
            v_res[#v_res] = ""
        }
        if paren {
            v_res[#v_res+1] = ")"
        }
    }
    if tail {
        for _, v in ipairs(tail) {
            if v[1] == "field" {
                visit_field(v)
            } else {
                visit_index(v)
            }
        }
    }
}

func visit_pair(node) {
    key := node[4]
    if key[1] == "id" && !key[5] && !key[6] {
        name := key[4]
        if KEYWORDS[name] || RESERVED[name] {
            v_res[#v_res+1] = "[\""
            visit_expr(key)
            v_res[#v_res+1] = "\"]"
        } else {
            visit_expr(key)
        }
    } else if key[1] == "index" {
        visit_index(key)
    } else {
        v_res[#v_res+1] = "["
        visit_expr(key)
        v_res[#v_res+1] = "]"
    }
    v_res[#v_res+1] = " = "
    visit_expr(node[5])
}

func visit_table(node) {
    if #node[4] == 0 {
        v_res[#v_res+1] = "{}"
        return
    }
    v_res[#v_res+1] = "{\n"
    v_level = v_level + 1
    for _, v in ipairs(node[4]) {
        v_res[#v_res+1] = space()
        if v[1] == "pair" {
            visit_pair(v)
            v_res[#v_res+1] = ";\n"
        } else {
            visit_expr(v)
            v_res[#v_res+1] = ",\n"
        }
    }
    v_level = v_level - 1
    v_res[#v_res+1] = space() .. "}"
}

func visit_list(node) {
    v_res[#v_res+1] = "{"
    list := node[4]
    if #list > 0 {
        for _, v in ipairs(list) {
            visit_expr(v)
            v_res[#v_res+1] = ", "
        }
        v_res[#v_res] = ""
    }
    v_res[#v_res+1] = "}"
}

func visit_paren(node) {
    v_res[#v_res+1] = "("
    visit_expr(node[4])
    v_res[#v_res+1] = ")"
}

func visit_unop(node) {
    op := LUA_OPS[node[4]]
    if op != "+" {
        v_res[#v_res+1] = LUA_OPS[node[4]]
    }
    visit_expr(node[5])
}

func visit_binop(node) {
    visit_expr(node[4])
    v_res[#v_res+1] = " " .. LUA_OPS[node[5]] .. " "
    visit_expr(node[6])
}

visit_func := nil

visit_expr = func(node) {
    t := node[1]
    if t == "id" {
        visit_id(node)
    } else if t == "binop" {
        visit_binop(node)
    } else if t == "unop" {
        visit_unop(node)
    } else if t == "paren" {
        visit_paren(node)
    } else if t == "value" {
        visit_value(node)
    } else if t == "table" {
        visit_table(node)
    } else if t == "list" {
        visit_list(node)
    } else if t == "func" {
        visit_func(node, true)
    } else if t == "vararg" {
        v_res[#v_res+1] = "..."
    } else {
        errorf("unknown node type: '%s'", t)
    }
}

visit_stmt := nil

func visit_body(node, skip_break) {
    v_level = v_level + 1
    for _, v in ipairs(node) {
        visit_stmt(v, skip_break)
    }
    v_level = v_level - 1
}

func visit_block(node, skip_break) {
    visit_body(node[4], skip_break)
}

func visit_call(node) {
    v_res[#v_res+1] = space()
    visit_id(node[4])
    v_res[#v_res+1] = "\n"
}

func visit_set(node) {
    v_res[#v_res+1] = space()
    for _, v in ipairs(node[4]) {
        visit_id(v)
        v_res[#v_res+1] = ", "
    }
    v_res[#v_res] = " = "
    for _, v in ipairs(node[5]) {
        visit_expr(v)
        v_res[#v_res+1] = ", "
    }
    v_res[#v_res] = "\n"
}

func visit_inc(node) {
    v_res[#v_res+1] = space()
    visit_id(node[4])
    v_res[#v_res+1] = " = "
    visit_id(node[4])
    v_res[#v_res+1] = " + "
    visit_expr(node[5])
    v_res[#v_res+1] = "\n"
}

func visit_dec(node) {
    v_res[#v_res+1] = space()
    visit_id(node[4])
    v_res[#v_res+1] = " = "
    visit_id(node[4])
    v_res[#v_res+1] = " - "
    visit_expr(node[5])
    v_res[#v_res+1] = "\n"
}

func visit_let(node) {
    v_res[#v_res+1] = space() .. "local "
    for _, v in ipairs(node[4]) {
        visit_id(v)
        v_res[#v_res+1] = ", "
    }
    v_res[#v_res] = " = "
    for _, v in ipairs(node[5]) {
        visit_expr(v)
        v_res[#v_res+1] = ", "
    }
    v_res[#v_res] = "\n"
}

func visit_if(node) {
    v_res[#v_res+1] = space() .. "if "
    visit_expr(node[4])
    v_res[#v_res+1] = " then\n"
    visit_block(node[5])
    _else := node[6]
    for _else {
        v_res[#v_res+1] = space() .. "else"
        if _else[1] == "if" {
            v_res[#v_res+1] = "if "
            visit_expr(_else[4])
            v_res[#v_res+1] = " then\n"
            visit_block(_else[5])
            _else = _else[6]
        } else {
            v_res[#v_res+1] = "\n"
            visit_block(_else)
            _else = nil
        }
    }
    v_res[#v_res+1] = space() .. "end\n"
}

func visit_switch(node) {
    expr := node[4]
    if expr {
        v_res[#v_res+1] = space() .. "do\n"
        v_level = v_level + 1
        v_res[#v_res+1] = space() .. "local case = "
        visit_expr(expr)
        v_res[#v_res+1] = "\n" .. space()
        for _, _case in ipairs(node[5]) {
            v_res[#v_res+1] = "if "
            case_exp := _case[5]
            if case_exp {
                v_res[#v_res+1] = "("
            }
            for _, item in ipairs(_case[4]) {
                v_res[#v_res+1] = "case == "
                if item[1] == "binop" {
                    v_res[#v_res+1] = "("
                    visit_expr(item)
                    v_res[#v_res+1] = ")"
                } else {
                    visit_expr(item)
                }
                v_res[#v_res+1] = " or "
            }
            if case_exp {
                v_res[#v_res] = ") and "
                visit_expr(case_exp)
            } else {
                v_res[#v_res] = ""
            }
            v_res[#v_res+1] = " then\n"
            visit_body(_case[6])
            v_res[#v_res+1] = space() .. "else"
        }
        _default := node[6]
        if _default {
            v_res[#v_res+1] = "\n"
            visit_body(_default)
        } else {
            v_res[#v_res] = ""
        }
        v_res[#v_res+1] = space() .. "end\n"
        v_level = v_level - 1
        v_res[#v_res+1] = space() .. "end\n"
    } else {
        v_res[#v_res+1] = space()
        for _, _case in ipairs(node[5]) {
            v_res[#v_res+1] = "if "
            visit_expr(_case[5])
            v_res[#v_res+1] = " then\n"
            visit_body(_case[6])
            v_res[#v_res+1] = space() .. "else"
        }
        _default := node[6]
        if _default {
            v_res[#v_res+1] = "\n"
            visit_body(_default)
        } else {
            v_res[#v_res] = ""
        }
        v_res[#v_res+1] = space() .. "end\n"
    }
}

func visit_for(node) {
    expr := node[4]
    block := node[5]
    body := block[4]
    if !expr && #body > 0 {
        last := body[#body]
        if last[1] == "break" {
            break_expr := last[4]
            if break_expr {
                v_res[#v_res+1] = space() .. "repeat\n"
                visit_block(block, true)
                v_res[#v_res+1] = space() .. "until "
                visit_expr(break_expr)
                v_res[#v_res+1] = "\n"
                return
            }
        }
    }
    v_res[#v_res+1] = space() .. "while "
    if expr {
        visit_expr(expr)
    } else {
        v_res[#v_res+1] = "true"
    }
    v_res[#v_res+1] = " do\n"
    visit_block(block)
    v_res[#v_res+1] = space() .. "end\n"
}

func visit_for_to(node) {
    v_res[#v_res+1] = space() .. "for "
    visit_id(node[4])
    v_res[#v_res+1] = " = "
    visit_expr(node[5])
    v_res[#v_res+1] = ", "
    visit_expr(node[6])
    step := node[7]
    if step {
        v_res[#v_res+1] = ", "
        visit_expr(step)
    }
    v_res[#v_res+1] = " do\n"
    visit_block(node[8])
    v_res[#v_res+1] = space() .. "end\n"
}

func visit_for_in(node) {
    v_res[#v_res+1] = space() .. "for "
    for _, v in ipairs(node[4]) {
        visit_id(v)
        v_res[#v_res+1] = ", "
    }
    v_res[#v_res] = " in "
    for _, v in ipairs(node[5]) {
        visit_expr(v)
        v_res[#v_res+1] = ", "
    }
    v_res[#v_res] = " do\n"
    visit_block(node[6])
    v_res[#v_res+1] = space() .. "end\n"
}

func visit_return(node) {
    list := node[4]
    v_res[#v_res+1] = space() .. "return"
    if list {
        v_res[#v_res+1] = " "
        for _, v in ipairs(list) {
            visit_expr(v)
            v_res[#v_res+1] = ", "
        }
        v_res[#v_res] = ""
    }
    v_res[#v_res+1] = "\n"
}

func visit_break(node) {
    expr := node[4]
    if expr {
        v_res[#v_res+1] = space() .. "if "
        visit_expr(expr)
        v_res[#v_res+1] = " then\n"
        v_level = v_level + 1
        v_res[#v_res+1] = space() .. "break\n"
        v_level = v_level - 1
        v_res[#v_res+1] = space() .. "end\n"
    } else {
        v_res[#v_res+1] = space() .. "break\n"
    }
}

func visit_continue(node) {
    v_res[#v_res+1] = space() .. "goto continue\n"
}

func visit_label(node) {
    v_res[#v_res+1] = space() .. "::" .. node[4] .. "::\n"
}

func visit_params(node) {
    t := {}
    for _, v in ipairs(node[4]) {
        t[#t+1] = v[4]
    }
    v_res[#v_res+1] = "("..table_concat(t, ", ")..")\n"
}

visit_func = func(node, lambda) {
    if lambda {
        v_res[#v_res+1] = "function"
    } else if node[7] {
        if node[8] {
            v_res[#v_res+1] = space() .. "function " .. node[7] .. ":" .. node[4]
        } else {
            v_res[#v_res+1] = space() .. "function " .. node[7] .. "." .. node[4]
        }
    } else {
        v_res[#v_res+1] = space() .. "local function " .. node[4]
    }
    visit_params(node[5])
    visit_block(node[6])
    v_res[#v_res+1] = space() .. "end"
    if !lambda {
        v_res[#v_res+1] = "\n"
    }
}

func visit_nop(node) {
    v_res[#v_res] = ";\n"
}

visit_stmt = func(node, skip_break) {
    t := node[1]
    if t == "call" {
        visit_call(node)
    } else if t == "set" {
        visit_set(node)
    } else if t == "inc" {
        visit_inc(node)
    } else if t == "dec" {
        visit_dec(node)
    } else if t == "let" {
        visit_let(node)
    } else if t == "if" {
        visit_if(node)
    } else if t == "switch" {
        visit_switch(node)
    } else if t == "block" {
        v_res[#v_res+1] = space() .. "do\n"
        visit_block(node)
        v_res[#v_res+1] = space() .. "end\n"
    } else if t == "for" {
        visit_for(node)
    } else if t == "for_to" {
        visit_for_to(node)
    } else if t == "for_in" {
        visit_for_in(node)
    } else if t == "return" {
        visit_return(node)
    } else if t == "break" {
        if !skip_break {
            visit_break(node)
        }
    } else if t == "continue" {
        visit_continue(node)
    } else if t == "label" {
        visit_label(node)
    } else if t == "func" {
        visit_func(node)
    } else if t == "nop" {
        visit_nop(node)
    } else if t == "const" {
        -- skip
    } else {
        errorf("unknown node type: %s", t)
    }
}

func visit_module(node, level) {
    v_res = {}
    v_level = level || 0
    for _, v in ipairs(node[4]) {
        visit_stmt(v)
    }
    return table_concat(v_res)
}

{
    fn := _G.arg[1]
    if fn {
        os, io, pcall, print := _G.os, _G.io, _G.pcall, _G.print
        src := io::open(fn, "r").read("a")
        r, m := pcall(parse_module, src, fn)
        if r {
            res := visit_module(m, 0)
            io::open(fn .. ".lua", "w").write(res)
            print(os::clock())
        } else {
            print(m)
            os::exit(1)
        }
    }
}

return {
    Node: Node,
    nodes: nodes,
    parse_module: parse_module,
    visit_module: visit_module,
}
